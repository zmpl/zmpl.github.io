<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL数据库总结"><meta name="keywords" content=""><meta name="author" content="zmpl"><meta name="copyright" content="zmpl"><title>MySQL数据库总结 | zmpl's blogs</title><link rel="shortcut icon" href="/hx.png"><link rel="stylesheet" href="/css/index.css?version=1.6.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="alternate" href="/atom.xml" title="zmpl's blogs" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL数据库总结"><span class="toc-number">1.</span> <span class="toc-text">MySQL数据库总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库的常见问题"><span class="toc-number">1.0.1.</span> <span class="toc-text">数据库的常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库"><span class="toc-number">1.1.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据表"><span class="toc-number">1.2.</span> <span class="toc-text">数据表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据查询"><span class="toc-number">1.3.</span> <span class="toc-text">数据查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单表查询"><span class="toc-number">1.3.1.</span> <span class="toc-text">单表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#正则表达式查询"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">正则表达式查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分组聚合查询"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">分组聚合查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多表查询"><span class="toc-number">1.3.2.</span> <span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内连接"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外连接"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">外连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子查询"><span class="toc-number">1.3.3.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合查询"><span class="toc-number">1.3.4.</span> <span class="toc-text">联合查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据更新"><span class="toc-number">1.4.</span> <span class="toc-text">数据更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据插入"><span class="toc-number">1.4.1.</span> <span class="toc-text">数据插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据更新-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">数据更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除数据"><span class="toc-number">1.4.3.</span> <span class="toc-text">删除数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#视图"><span class="toc-number">1.5.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建视图"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改视图定义"><span class="toc-number">1.5.2.</span> <span class="toc-text">修改视图定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除视图定义"><span class="toc-number">1.5.3.</span> <span class="toc-text">删除视图定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新视图定义"><span class="toc-number">1.5.4.</span> <span class="toc-text">更新视图定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触发器"><span class="toc-number">1.6.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建触发器"><span class="toc-number">1.6.1.</span> <span class="toc-text">创建触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除触发器"><span class="toc-number">1.6.2.</span> <span class="toc-text">删除触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用触发器"><span class="toc-number">1.6.3.</span> <span class="toc-text">使用触发器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件"><span class="toc-number">1.7.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建事件"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改事件"><span class="toc-number">1.7.2.</span> <span class="toc-text">修改事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除事件"><span class="toc-number">1.7.3.</span> <span class="toc-text">删除事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储过程"><span class="toc-number">1.8.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建存储过程"><span class="toc-number">1.8.1.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#储存过程体"><span class="toc-number">1.8.2.</span> <span class="toc-text">储存过程体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建游标"><span class="toc-number">1.8.3.</span> <span class="toc-text">创建游标</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="images/hx.png"></div><div class="author-info__name text-center">zmpl</div><div class="author-info__description text-center">不经一番寒彻骨，怎得梅花扑鼻香</div><div class="follow-button"><a href="https://github.com/zmpl" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(images/index.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zmpl's blogs</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">MySQL数据库总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-15</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="MySQL数据库总结"><a href="#MySQL数据库总结" class="headerlink" title="MySQL数据库总结"></a>MySQL数据库总结</h1><h3 id="数据库的常见问题"><a href="#数据库的常见问题" class="headerlink" title="数据库的常见问题"></a>数据库的常见问题</h3><ol>
<li><p>数据库的默认端口:3306<br>常见名词:<br>DB:数据库<br>DBS:数据库系统<br>DBMS:数据库管理系统<br>DBMA:数据库管理人员</p>
</li>
<li><p>sql的功能:<br>DDL:数据定义功能 CREATE  、ALTER、DROP<br>DBML:数据操纵功能 SELECT、insert、update、delete<br>mDCL:数据控制功能 安全管理 grant、revoke</p>
</li>
<li><p>数据库使用的语言: 结构化查询语言sql</p>
</li>
<li><p>常量:<br>字符串常量、数值常量、十六进制常量、日期时间常量、位字段值、布尔值、NULL值</p>
</li>
<li><p>变量:<br>用户变量:<br>   <code>@one</code><br>系统变量:<br>  <code>@@two</code>    </p>
</li>
</ol>
<ol start="7">
<li>运算符:<br>  <code>&#39;+&#39; &#39;-&#39; &#39;*&#39; &#39;/&#39; &#39;%&#39;</code><br>  <code>&#39;&amp;&#39; &#39;|&#39; &#39;^&#39; &#39;~&#39; &#39;&gt;&gt;&#39; &#39;&lt;&lt;&#39;</code><br>  <code>&#39;=&#39; &#39;&gt;=&#39; &#39;&lt;=&#39; &#39;&gt;&#39; &#39;&lt;&#39; &#39;!=&#39; &#39;&lt;&gt;&#39; &#39;&lt;=&gt;&#39;</code>(相等或都等于空)</li>
<li>常用内置函数:<br>数学函数:<code>abs(),sqrt(),floor(),rand(),truncate()</code>,<br>聚合函数: <code>COUNT(),sum(),avg(),max(),min()</code>,<br>字符串函数: <code>ASCii(),char(),substring(),concat(),upper(),ucase(),lower(),left()</code>,<br>日期和时间函数: <code>now(),year(),month(),day(),curdate(),current_date(),curtime(),current_time()</code>,<br>加密函数: <code>encode(),encrypt()</code>,<br>控制流程函数: <code>if(),ifNULL()</code>,<br>格式化函数: <code>format()</code>,<br>类型转换函数:<code>case()</code>,<br>系统信息函数: <code>user(),version()</code>,</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li><p>数据库的创建:<br><code>CREATE   database | schema db_name;</code><br>db_name的命名规则:可以是0-9,26个英文字母和’_’ ‘#’组成,不能是数据库中的关键字或保留字<br>创建的时候指定默认字符集和默认校对规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   database | schema db_name;</span><br><span class="line">     default character set 字符集名称</span><br><span class="line">     default collate 校对规则名称;</span><br></pre></td></tr></table></figure>
<p>常用字符集:<code>utf8 gb2312 gbk</code><br>常用校对规则 <code>utf8_general_ci gb2312_chinese_ci gbk_chinese_ci</code></p>
</li>
<li><p>数据库的修改<br>修改数据库的默认字符集和默认校对规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER database | schema db_name</span><br><span class="line"> default character set 字符集名称</span><br><span class="line"> default collate 校对规则名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库的删除<br><code>DROP database | schema db_name;</code></p>
</li>
<li><p>选择数据库<br><code>use db_name;</code></p>
</li>
<li><p>关于数据库的一些信息查询<br>查看当前选择的数据库<br>  <code>SELECT database() | schema();</code><br>查看mysql中所有的的数据库<br>  <code>show database | schemas;</code><br>查看mysql中支持的字符集和与字符集对应的默认校对规则<br>   <code>show charset;</code><br>查看mysql中支持的校对规则<br>   <code>show collation;</code><br>查看默认字符集<br>   <code>show variables like &#39;character%&#39;;</code><br>查看默认校对规则<br>   <code>show variables like &#39;collation%&#39;;</code><br>查看mysql支持的存储引擎<br>   <code>show engines;</code><br>查看当前登录的用户<br>  <code>SELECT user();</code><br>查看mysql的版本<br>  <code>SELECT version();</code></p>
</li>
</ol>
<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><ol>
<li><p>表的创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE tb_name</span><br><span class="line">(   </span><br><span class="line">    col_name1 INT,</span><br><span class="line">    col_name2 char(20),</span><br><span class="line">    col_name3 VARCHAR(20),</span><br><span class="line">    col_name4 float(7),</span><br><span class="line">  	 ......</span><br><span class="line">)engine=engine_name;</span><br></pre></td></tr></table></figure>

<p>tb_name的命名规则和数据库名一样<br>字符的数据类型可以是:<br><code>bit,tinyINT,smALLINT,mediumINT,INT,INTeger,bigINT</code><br><code>real,double,float,decimal,numeric</code> 表示指定精度的浮点型数值<br><code>date,time,timestamp,datetime</code><br><code>char,VARCHAR,text,tinytext</code><br><code>blob,mediumblobm,longblob,tinytext,text,mediumtext,longtext</code><br><code>enum(value1,value2,value3,...)</code><br><code>set(value1,value2,value3,value4,value5)</code></p>
</li>
<li><p>自增属性:auto_increment 只能定义在INT类型上 自动增长的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT auto_increment PRIMARY KEY,</span><br><span class="line">  testname VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>修改表<br> ALTER后面可以跟上多个MODIFY,change子句,子句之间用逗号隔开<br> <strong>添加字段</strong><br> 添加在所有字段前面<br>  <code>ALTER TABLE test add testno INT first;</code><br> 添加在某个字段后面<br>  <code>ALTER TABLE test add testno INT after col_name;</code><br> <strong>修改字段</strong><br> 修改数据类型,字段位置<br><code>ALTER TABLE tb_name MODIFY testno char(20) after col_name;</code><br>修改字段名,字段位置,数据类型<br><code>ALTER TABLE tb_name changes testno tno INT after col_name;</code><br>修改字段默认值<br><code>ALTER TABLE tb_name ALTER [column] testno set default &#39;1&#39;;</code><br><strong>删除字段</strong><br><code>ALTER TABLE tb_name DROP col_name;</code><br><strong>重命名表</strong><br>方法1:<br><code>ALTER TABLE old_tb_name rename to new_tb_name;</code><br>方法2:<br><code>rename TABLE old_tb_name to new_tb_name</code>;<br>修改多个表名<br><code>rename TABLE old_tb_name to new_tb_name,old2_tb_name to new2_tb_name,......;</code><br> <strong>删除表</strong><br> <code>DROP TABLE tb_name;</code><br> <strong>查看表的相关信息</strong><br>查看当前库某个表的结构<br> <code>DESC tb_name;</code><br> <code>show columns FROM | in tb_name;</code><br>查看某个库某个表的结构<br>  <code>show columns FROM | in tb_name FROM | INT db_name;</code><br>查看当前库某个表的详细结构<br>   <code>show CREATE   TABLE tb_name \g | \G</code>  –&gt; \g的作用是以列表的形式查询内容 \g是以表格的形式查看内容</p>
</li>
<li><p>实体完整性约束<br>主键约束:<code>PRIMARY KEY</code><br>表级创建语法:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT,   # -- &gt;&gt;&gt;INT默认长度11</span><br><span class="line">  testname VARCHAR(20),</span><br><span class="line">   CONSTRAINT test_pr PRIMARY KEY(testno)  #-- &gt;&gt;&gt;主键可以自定义名,但是定义无效</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   列级创建语法:<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT PRIMARY KEY,</span><br><span class="line">  testname VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>   一个表中只能存在一个主键,主键可以定义在多列上形成复合主键。<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT,</span><br><span class="line">  testname VARCHAR(20),</span><br><span class="line">  testnum INT,</span><br><span class="line">  PRIMARY KEY(testno,testnum)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>   定义主键的时候同时会增加一个主键索引<br>   定义的主键上不能出现空值</p>
<p>   <code>ALTER TABLE</code>的方式对已存在的表添加主键:<br>   <code>ALTER TABLE test add CONSTRAINT test_pr PRIMARY KEY(test);</code><br>   添加复合主键的方式与添加主键的方式相同<br>   <code>ALTER TABLE test add CONSTRAINT test_pr PRIMARY KEY(test,test2,...);</code></p>
<p>  候选键约束:UNIQUE KEY<br>  候选键又称唯一约束,候选键的值必须是唯一的,并且不能为空<br>   表级创建语法<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">testno INT,</span><br><span class="line">testname VARCHAR(20),</span><br><span class="line">testnum INT,</span><br><span class="line">CONSTRAINT uk_tno UNIQUE KEY(testno),</span><br><span class="line">CONSTRAINT uk_tname_tnum UNIQUE KEY(testname,testnum)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>   列级创建语法<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">testno INT UNIQUE KEY,</span><br><span class="line">   testname VARCHAR(20) UNIQUE KEY,</span><br><span class="line">   testnum INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>  删除候选键约束:<br>    <code>ALTER TABLE test DROP index uk_name;</code> –&gt;<code>uk_name</code>:候选键约束名<br>  或 <code>DROP index uk_name on test;</code></p>
<ol start="5">
<li><p>参照性约束<br> 参照完整性规则定义的是外键与主键之间的引用规则,即外键的取值或为空,或者等于被参照关系中某个主键的值。<br> 定义外键的规则:</p>
<ul>
<li><p>被参照表必须已创建或者正在创建,被参照表是正在创建的表那参照表也是正在创建的表</p>
</li>
<li><p>被参表必须定义主键或候选键</p>
</li>
<li><p>必须在被参表的表名后面指定列名或列名的组合，这个列或列组合必须是被参照表的主键或候选键</p>
</li>
<li><p>主键不能包含空值,但允许在外键中出现空值.这意味着只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的</p>
</li>
<li><p>外键对应列的数目必须和参照表的主键对应列的数目相同</p>
</li>
<li><p>外键对应列的数据类型必须和被参照表的主键对应列的数据类型相同</p>
</li>
<li><p>外键只能定义在主键或候选键上</p>
</li>
<li><p>外键只能定义在<code>innodb</code>表上</p>
</li>
</ul>
<p>表级创建语法:</p>
<p>被参照表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test1</span><br><span class="line">(</span><br><span class="line">   testno INT PRIMARY KEY,</span><br><span class="line">   testname VARCHAR(20),</span><br><span class="line">   testnum INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>参照表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test2</span><br><span class="line">(</span><br><span class="line">   testno INT,</span><br><span class="line">   testname VARCHAR(20),</span><br><span class="line">   testnum INT,</span><br><span class="line">   CONSTRAINT fk_tno FOREIGN KEY(testno) references test1(testno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>关闭外键检查</p>
<pre><code>`set foreign_key_checks=0;`</code></pre><p>开启外键检查</p>
<pre><code>`set foreign_key_checks=1;`</code></pre></li>
<li><p>用户定义的完整性约束</p>
<p>非空约束:指字段值不能为空</p>
<p>创建语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. CREATE   TABLE</span><br><span class="line">   CREATE   TABLE test</span><br><span class="line">   (</span><br><span class="line">      testno INT NOT NULL UNIQUE KEY,</span><br><span class="line">      testname VARCHAR(20) UNIQUE KEY,</span><br><span class="line">      testnum INT</span><br><span class="line">   );</span><br><span class="line">2. ALTER TABLE</span><br><span class="line">   ALTER TABLE test MODIFY testno INT NOT NULL;</span><br><span class="line">      					</span><br><span class="line">   ALTER TABLE test change testno tno INT NOT NULL;</span><br></pre></td></tr></table></figure>

<p>默认值约束</p>
<p>创建语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. CREATE   TABLE</span><br><span class="line">   CREATE   TABLE test</span><br><span class="line">   (</span><br><span class="line">      testno INT default &apos;1&apos; UNIQUE KEY,</span><br><span class="line">      testname VARCHAR(20) UNIQUE KEY,</span><br><span class="line">      testnum INT</span><br><span class="line">   );</span><br><span class="line">2. ALTER TABLE</span><br><span class="line">   ALTER TABLE test MODIFY testno INT default &apos;1&apos;;</span><br><span class="line">      					</span><br><span class="line">   ALTER TABLE test change testno tno default &apos;1&apos;;</span><br></pre></td></tr></table></figure>

<p>更新约束:</p>
<p>添加约束:</p>
<p><code>ALTER TABLE test add [CONSTRAINT] {FOREIGN KEY | PRIMARY KEY | UNIQUE KEY}(col_name,col2_name,......);</code></p>
<p>删除外键约束:</p>
<p><code>ALTER TABLE test DROP FOREIGN KEY fk_name;</code>  –&gt; fk_name: 外键约束名</p>
</li>
</ol>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [ALL|distinct|distinctrow] &lt;目标列表达式1&gt; [,&lt;目标列表达式2&gt;]...</span><br><span class="line">		FROM &lt;表名1或视图1&gt; [,表名2或视图名2]...</span><br><span class="line">		[WHERE &lt;条件表达式&gt;]</span><br><span class="line">		[GROUP BY &lt;列名 1&gt; [HAING &lt;条件表达式&gt;]]</span><br><span class="line">		[ORDER BY &lt;列名1&gt; [ASC|DESC]]</span><br><span class="line">		[LIMIT [m,]n];</span><br></pre></td></tr></table></figure>
<p>查询表中所有数据包括重复行(默认包括重复行）<br><code>SELECT ALL * FROM test;</code><br>查看表中所有数据不包括重复行<br><code>SELECT distinct * FROM test;</code><br>查看某个列<br><code>SELECT col_name FROM test;</code><br>查看多个列用’,’号隔开<br><code>SELECT col_name1,col_name2,...,col_nameN FROM test;</code><br>查看所有列|字段<br><code>SELECT *|ALL col_name FROM test;</code><br>条件查询<br>比较: =,&lt;&gt;,!=,&lt;,&lt;=,&gt;,&gt;=,!&lt;,!&gt;,NOT+含比较运算符的表达式<br>确定范围:<code>between and,NOT between and</code><br>确定集合:<code>in,NOT in</code><br>字符匹配:<code>like,NOT like</code><br>空值:<code>is NULL,is NOT NULL</code><br>多重条件:<code>and,or</code> </p>
<p>例子:<br>查询score表中分数&gt;60的相关信息<br><code>SELECT * FROM score WHERE grade&gt;60;</code><br>查询student中籍贯不是江西的所有信息<br><code>SELECT * FROM student WHERE native!=&#39;江西&#39;;</code><br>查询score表中分数在60-80的相关信息<br><code>SELECT * FROM score WHERE grade between 60 and 80;</code><br>查询score中分数不在60-80的相关信息<br><code>SELECT * FROM score WHERE grade NOT between 60 and 80;</code><br>查看籍贯是上海,深圳,香港的学生信息<br><code>SELECT * form student WHERE native in(&#39;上海&#39;,&#39;深圳&#39;,&#39;香港&#39;);</code><br>查看籍贯不是上海,深圳,香港的学生信息<br><code>SELECT * FROM student WHERE native NOT in(&#39;上海&#39;,&#39;深圳&#39;,&#39;香港&#39;);</code><br>查看姓名中有’明’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;%明%&#39;;</code><br>查看姓’张’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;张%&#39;;</code><br>查看姓名中最后一个字为’恒’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;%恒&#39;;</code><br>查看名字为3个字且以’刘’开头的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;刘__&#39;</code><br>查看名字为3个字且第二个字为’空’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;_空_&#39;;</code><br>查看名字为3个字且第三个字为’浪’的学生信息<br><code>SELECT * FROM student whee studentname like &#39;__浪&#39;;</code><br>查看手机号码为空的学生信息<br><code>SELECT * FROM student WHERE phonenumber is NULL;</code><br>查看手机号码不为空的学生信息<br><code>SELECT * FROM student WHERE phonenumber is NOT NULL;</code><br>查看性别为男且有手机号码的学生信息<br><code>SELECT * FROM student WHERE sex=&#39;男&#39; and phonenumber is NOT NULL;</code><br>查看民族是汉族或其他民族的学生信息<br><code>SELECT * FROM student WHERE nation=&#39;汉&#39; or nation=&#39;壮&#39;;</code></p>
<h4 id="正则表达式查询"><a href="#正则表达式查询" class="headerlink" title="正则表达式查询"></a>正则表达式查询</h4><p>[NOT][regexp][rlike] &lt;正则表达式&gt;<br>规则:</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">说明</th>
<th align="center">例子</th>
<th align="center">匹配值示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;字符串&gt;</td>
<td align="center">匹配包含指定字符串的文本</td>
<td align="center">‘fa’</td>
<td align="center">fan,afa,faad</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">匹配[]中的任何一个字符</td>
<td align="center">‘[ab]’</td>
<td align="center">bay,big,app</td>
</tr>
<tr>
<td align="center">[^]</td>
<td align="center">匹配不在[]中的任何一个字符</td>
<td align="center">‘[^ab]’</td>
<td align="center">desk,cool,six</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配文本的开始字符</td>
<td align="center">‘^b’</td>
<td align="center">bed,brige,book</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配文本的结尾字符</td>
<td align="center">‘er$’</td>
<td align="center">driver,worker,farmer</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配任意单个字符</td>
<td align="center">‘b.t’</td>
<td align="center">better,bit,bite</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">匹配0个或多个*前面指定的字符</td>
<td align="center">‘f*n’</td>
<td align="center">fn,fan,begin</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">匹配+前面的字符1次或多次</td>
<td align="center">‘ba+’</td>
<td align="center">bat,baa,battle,bala</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="center">匹配前面的字符至少n次</td>
<td align="center">‘b{2}’</td>
<td align="center">bb,bbbb,bbbbbbb</td>
</tr>
</tbody></table>
<p>例子:</p>
<p>查看出版社名称中带’教育’的图书信息<br><code>SELECT * FROM tb_book WHERE publisher regexp &#39;教育&#39;;</code><br>查看图书名称中带’p’或’m’的图书信息<br><code>SELECT * FROM tb_book WHERE bname regexp &#39;[pm]&#39;;</code><br>查看图书名称中不带’高’的图书信息<br><code>SELECT * FROM tb_book WHERE bname NOT regexp &#39;高&#39;;</code><br>查看班级号以’A’开头的成绩信息<br><code>SELECT * FROM score WHERE c_no regexp &#39;^A&#39;;</code><br>查看学号中包含’2’和’4’的成绩信息<br><code>SELECT * FROM score WHERE s_no regexp &#39;2*4&#39;;</code><br>查看班级号以’1’结尾的成绩信息<br><code>SELECT * FROM score WHERE c_no regexp &#39;1$&#39;;</code><br>查看学号中包含’08’的成绩信息<br><code>SELECT * FROM score WHERE s_no regexp &#39;08+&#39;;</code><br>查看学号中包含’23’的成绩信息<br><code>SELECT * FROM score WHERE s_no regexp &#39;23{1}&#39;;</code></p>
<p>空值查询</p>
<p>空值一般表示数据未知、不确定或以后再添加,空值不等同于0,也不同于空字符串。<br>    判断字段内容是否为空不能用’=’<br>判断空值使用 IS NULL<br><code>SELECT * FROM tb_course WHERE priorCourse is null;</code><br>判断字段内容不为空<br><code>SELECT * FROM tb_course WHERE priorCourse is not null;</code></p>
<p>对查询结果排序</p>
<p><code>ORDER BY col_name[,col2_name,...][ASC | DESC];</code>  –&gt; ORDER BY子句放在WHERE子句之后<br>查询tb_student表中学生的信息并按姓名升序排列<br><code>SELECT * FROM tb_student ORDER BY studentName[ASC];</code>   –&gt; 排序默认升序<br>查询tb_score表中学生的成绩信息并按成绩降序排序<br><code>SELECT * FROM tb_score ORDER BY score DESC</code><br>对多个字段排序<br>查询tb_score表中的成绩信息并按学号升序排序再按成绩降序排序<br><code>SELECT * FROM tb_score ORDER BY studentNo ASC,score DESC;</code><br>查询tb_student表中学生的信息并按姓名降序排列再按班级号升序排列<br><code>SELECT * FROM tb_student ORDER BY studentName DESC,classNo ASC;</code></p>
<p>限制查询结果的数量</p>
<p>LIMIT [位置偏移量] 行数   –&gt; 位置偏移量是指相对于第一行这个位置偏移了多少行<br>                                            –&gt; LIMIT子句放在ORDER BY 子句之后<br>查询tb_score表中学生的成绩信息并按成绩降序排序,只查看前3名<br><code>SELECT * FROM tb_score ORDER BY score DESC limit 0,3;</code><br>LIMIT 行数 OFFSET 位置偏移量<br>查询tb_score表中学生的成绩并按成绩升序排列,只看倒数3名<br><code>SELECT * FROM tb_score ORDER BY score ASC limit 3 OFFSET 0;</code></p>
<h4 id="分组聚合查询"><a href="#分组聚合查询" class="headerlink" title="分组聚合查询"></a>分组聚合查询</h4><p>GROUP BY<br>聚合函数:<code>COUNT(*)</code>                    –&gt; 统计数据表中的记录数<br><code>COUNT(col_name)</code>                        –&gt; 统计一列中值的个数<br><code>MAX(col_name)</code>                        –&gt; 求一列中值的最大值<br><code>MIN(col_name)</code>                        –&gt; 求一列中值的最小值<br><code>SUM(col_name)</code>                        –&gt; 求一列中值的总和<br><code>AVG(col_name)</code>3 c   s                        –&gt; 求一列中值的平均值<br>除COUNT(*)外其它聚合函数包括COUNT(col_name)都会忽略空值                                      </p>
<p>聚合查询例子  </p>
<p>查询tb_student表中学生的总数<br><code>SELECT COUNT(*) FROM tb_student;</code><br>查询tb_student表中学生的总数,给字段取别名学生总数<br><code>SELECT COUNT(*) 学生总数 FROM tb_student;</code>   –&gt; 字段名后面空一格加上别名<br>或<br><code>SELECT COUNT(*) AS 学生总数 FROM tb_student;</code>    –&gt; 字段名后面空一格加上AS 别名<br>查询tb_score中选了课的学生总数并以别名的形式输出<br><code>SELECT COUNT(DISTINCT studentNo) AS 学生总数 FROM tb_score;</code><br>查询tb_score中成绩最高的学生的成绩信息<br><code>SELECT * FROM tb_score WHERE score=(SELECT MAX(score) FROM tb_score);</code><br>查询tb_score中最低的成绩<br><code>SELECT MIN(score) FROM tb_score;</code><br>查询tb_score表中成绩的平均值<br><code>SELECT AVG(SCORE) FROM tb_score;</code><br>查询tb_score表中所有成绩的总和<br><code>SELECT SUM(score) FROM tb_score;</code>                                                            </p>
<p>分组聚合查询例子</p>
<p>查询tb_student表中每个班级的总人数<br><code>SELECT classNo,COUNT(*) FROM tb_student GROUP BY classNo;</code><br>查询每个课程的学生平均成绩<br><code>SELECT courseNo,AVG(score) FROM tb_score GROUP BY courseNo;</code><br>查询每个学生的选课数,平均分,最高分<br><code>SELECT studentNo,COUNT(*) 选课数,AVG(SCORE) 平均分,MAX(score) 最高分 FROM tb_score GROUP BY studentNo;</code><br>查询有2门以上(含2门)课程成绩大于88分的学生学号及(88分以上的)课程数<br><code>SELECT studentNo,COUNT(*) 课程数 FROM tb_score WHERE score&gt;88 GROUP BY studentNo having COUNT(*)&gt;=2;</code><br>查询所有学生选课的平均成绩,但只有当平均成绩大于80的情况下才输出<br><code>SELECT AVG(score) AS 别名 FROM tb_score HAVING AVG(score)&gt;80;</code>    –&gt; HAVING短语在数据分组后进行过滤,WHERE短语在数据分组前进行过滤<br> –&gt; HAVING短语没有接GROUP BY短语会将所有记录分在一个组<br>–&gt; 示例待补充…</p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>交叉连接<br>CROSS JOIN 又称笛卡尔积,即把每一张表的每一行与另一张表的每一行连接起来,返回两张表的每一行相连接后所有可能的结果<br>语法:<br>SELECT * FROM 表1 CROSS JOIN 表2;<br>或<br>SELECT * FROM 表1,表2;<br>因为返回的查询结果集等于两张表记录行数的乘积,所以交叉连接的结果集会非常庞大,且查询执行时间特别长,甚至有可能因为返回的数据过多而造成系统的停滞不前,因此对于存在大量数据的表,应避免使用交叉连接。</p>
<p>例子:<br>查询tb_student和tb_score表的所有可能结果<br>SELECT * FROM tb_student CROSS JOIN tb_score; </p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>INNER JOIN 通过在查询中设置连接条件来移除交叉连接查询的结果集中某些数据行。<br>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表1 INNER JOIN 表2 INNER JOIN 表3        </span><br><span class="line">ON 连接条件</span><br><span class="line">[WHERE 过滤条件];--&gt; 字段列表里可以是要检索的字段名或者是别名</span><br><span class="line">					或使用WHERE子句定义连接条件的隐式语法结构</span><br><span class="line">					SELECT * FROM 表1,表2 WHERE 连接条件 [AND 过滤条件];     				   --&gt; 字段列表里可以是要检索的字段名或者是别名</span><br></pre></td></tr></table></figure>
<p>等值与非等值连接<br>[&lt;表明1&gt;.]&lt;字段名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;字段名2&gt;<br>其中比较运算符主要要:=,&gt;,&lt;,&gt;=,&lt;=,!=(&lt;&gt;).当比较运算符为’=’时表示等值连接<br>例子:<br>查询每个学生的信息和成绩信息<br><code>SELECT * FROM tb_student t,tb_score e where t.studentNo=e.studentNo;</code><br>自连接<br>若某个表与自身进行连接,称为自表连接或自身连接,简称自连接.使用自连接时,需要为表指定多个不同的别名,且对所有查询字段的引用必须使用表别名限定,否则SELECT操作会失败</p>
<p>例子:<br>查询与’数据库’这门课学分相同的课程信息<br><code>SELECT c1.* FROM tb_course c1,tb_course c2 WHERE c1.credit=c2.credit and c2.courseName=&#39;数据库&#39; AND c1.courseName!=&#39;数据库&#39;;</code><br>自然连接<br>NATURAL JOIN 只用当连接字段在两张表的字段都相同时才可使用,否则返回的是笛卡尔积的结果集。</p>
<p>例子:</p>
<p>查询每个学生的信息和选课情况</p>
<p><code>select * from tb_student natural join tb_score;</code></p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>左外连接<br>左外连接，也称左连接(LEFT OUTER JOIN 或 LEFT JOIN)，用于返回该关键字左边表(基表)的所有记录，并用这些记录与该关键字右边表(参考表)的记录进行匹配，如果左表的某些记录在右表中没有匹配的记录，就和右表中的”万能行”连接，即右表对应的字段值全部设置为NULL。    </p>
<p>例子:</p>
<p>林海同学加入时未选课。</p>
<p><code>select a.studentNo studentNo,studentName,sex,classNo,courseNo,score from tb_student a left outer join tb_score b on a.studentNo=b.studentNo;</code></p>
<p>使用LEFT OUTER JOIN用on指定连接条件。</p>
<p>使用LEFT JOIN可以用where也可以用on指定连接条件。<br>右外连接</p>
<p>右外连接，也称右连接(RIGHT OUTER JOIN 或RIGHT JOIN)，以右表为基表，其连接方法和左外连接完全一样。即返回右表的所有记录，并用这些记录与左边表(参考表)中的记录进行匹配，如果右表的某些记录在左表中没有匹配的记录，左表对应的字段全部被设置为NULL。 </p>
<p> 例子:</p>
<p><code>select score,b.studentNo studentNo,studentName,sex,classNo from tb_score b right outer join tb_student a on b.studentNo=a.studentNo;</code></p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询也称嵌套查询，是将一个查询语句嵌套在另一个查询语句的where子句或having短语中，前者被称为内层查询或子查询，后者被称为外层查询或父查询。在整个语句中，执行顺序是先进行子查询，然后将子查询的返回结果作为父查询的筛选条件。</p>
<ol>
<li><p>带in关键字的子查询</p>
<p>带in关键字的子查询，一般用于判断某个值是否在某个区间。</p>
<p><strong>注意:</strong>内层查询只返回一行数据咧。</p>
<p>例:</p>
<p>查询籍贯为上海或北京的学生信息</p>
<p><code>select * from tb_student where native in(select native from tb_student where native=&#39;上海&#39; || native=&#39;北京&#39;);</code></p>
</li>
<li><p>带比较运算符的子查询</p>
<p>带比较运算符的子查询，一般用于将某个字段值跟特定的值比较。</p>
<p><strong>注意:</strong>内层查询只能返回一个数据。</p>
<p>例:</p>
<p>查询班级为和江山同一个班的学生信息。</p>
<p><code>select * from tb_student where classNo=(select classNo from tb_student where studentName=&#39;江山&#39;) and studentName!=&#39;江山&#39;;</code></p>
</li>
<li><p>带exists关键字的子查询</p>
<p>exists的子查询是否有结果，有返回true否则返回false</p>
<p>not exists与exists意义相反。</p>
<p>not exists内可以继续使用not exists双重否定变肯定。</p>
<p>例:</p>
<p>查询没有选修31002的学生姓名</p>
<p><code>select studentName from tb_student a where not exists(select * from tb_score b where a.studentNo=b.studentNo and courseNo=&#39;31002&#39;);</code></p>
<p>查询选修了所有课的学生姓名</p>
<p><code>select studentName from tb_student a where not exists(select * from tb_course c where not exists(select * from tb_score b where a.studentNo=b.studentNo and courseNo=c.courseNo));</code></p>
</li>
</ol>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>   使用union关键字可以将来自多个select语句结果集合到一个结果集中。合并时，多个select子句中对应的字段数和数据类型必须相同。</p>
<p>   语法:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT -FROM-WHERE</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT -FROM-WHERE</span><br><span class="line">[...UNION [ALL]]</span><br><span class="line">SELECT -FROM-WHERE]</span><br></pre></td></tr></table></figure>

<p>使用ALL关键字，执行的时候返回返回所有记录，包括重复的记录。</p>
<p>不适用ALL关键字，则会去掉重复记录，也不对结果进行自动排序。</p>
<p>例:</p>
<p>查询所有老师的姓名和学生的姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sname name from students</span><br><span class="line">union</span><br><span class="line">select tname from teachers;</span><br></pre></td></tr></table></figure>

<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p>插入完整的数据记录不省略字段名,可以部分/完整字段插入<br><code>insert into tb_name(column_list) values(value_list);</code>                    </p>
<p>省略字段名,只能是全部字段插入<br><code>insert into tb_name values(value_list);</code></p>
<p>同时插入多条数据记录,可以部分/完整字段插入<br><code>insert into tb_name(column_list) values(value_list1),(value_list2),...,(value_listn);</code></p>
<p>插入查询结果<br><code>insert into tb_name1(column_list1) select column_list2 from tb_name2 where condition;</code></p>
<p>使用replace语句插入数据<br>如果一个待插入的表中存在有primary key或unique约束，而待插入的数据行中包含与待插入表中数据行相同的    primary key或unique列值，那么insert语句将无法插入此行。这时只能用replace语句插入数据，replace语句    插入的数据会将原来相同的数据删除,从而保证新纪录能够正常插入。<br><code>replace into tb_name(column_list) values(value_list);</code></p>
<h3 id="数据更新-1"><a href="#数据更新-1" class="headerlink" title="数据更新"></a>数据更新</h3><p>修改特定表该字段所有数据记录<br><code>update tb_name set column1=value1,column2=value2,...,columnn=valuen;</code></p>
<p>修改特定表指定的数据记录<br><code>update tb_name
set column1=value1,column2=value2,...,columnn=valuen
where conditions;</code></p>
<p>带子查询的修改<br><code>update tb_name
set column1=value1,column2=value2,...,columnn=valuen
where column_name=(select column[,column1,...,columnn] from tb_name);</code></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除一个表所有数据<br><code>delete from tb_name;</code></p>
<p>清空表数据<br><code>truncate table tb_name;</code></p>
<p>删除指定表特定数据<br><code>delete from tb_name where conditions;</code></p>
<p>带子查询的删除<br><code>delete from tb_name where column_name in(select column[,column1,...,columnn] from tb_name);</code></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从一个或多个表或者视图中导出的表，它也包含一系列带有名称的的数据列和若干条数据行。</p>
<p>视图与真实表的区别:<br>(1).视图不是真实的表，是虚拟表，它的结构和数据是建立在数据库中真实表的查询基础上。<br>(2).视图不是以数据集的形式存储在数据库中，它所对应的数据实际上是存储在视图所引用的真实表。<br>(3).视图本身并不存储数据。<br>(4).集中分散数据。<br>(5).简化查询语句。<br>(6).重用SQL语句。<br>(7).保护数据安全。<br>(8).共享所需数据。<br>(9).更改数据格式</p>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [or replace] view view_name [column_list]</span><br><span class="line">as select_statement</span><br><span class="line">[with [cascaded | local] check option]</span><br></pre></td></tr></table></figure>

<p>or replace:如果视图已存在则替换存在的视图</p>
<p>view_name:视图名</p>
<p>column_list:视图每个列的名称，列名的数据必须等同于select语句检索出的结果数据集的列数。</p>
<p>select_statement:用于指定创建视图的select语句，给出视图的定义，它可用于查询多个基础表或源视图中相同的列名。</p>
<p><strong>注意</strong></p>
<p>(1).定义视图的用户除了要求被授予create view的权限外，还必须授予可以操作视图所涉及的基础表或其他视图的相关权限。    </p>
<p>(2).select语句不能包含from子句中的子查询。</p>
<p>(3).select语句不能引用系统变量或用于变量。</p>
<p>(4).select语句不能引用预处理语句参数。</p>
<p>(5).在select语句中引用的表或视图必须存在。但是在创建完视图后可以删除引用的表或视图。</p>
<p>(6).若select语句中引用的不是当前数据库的基础表或源视图时，需要在该表或视图前加上数据库的名称作为限定前缀。</p>
<p>(7).在由select语句构造的视图定义中，允许使用order by子句。但是如果从特定视图进行了选择，而该视图使用了自己的order by语句，则视图定义中的order by子句将被忽略。</p>
<p>(8).对于select语句中的其他选项或子句，若所创建的视图中包含了这些选项，则语句执行效果未定义。</p>
<p>with check option:用于指定在可更新视图上进行的修改都需要符合select_statement中所指定的限定条件。当视图引用另一个视图时，有两个参数:cascaded和local，它们决定检查测试的范围。<br>            cascaded是默认值，它会对所有视图进行检查，local只对定义的视图进行检查。</p>
<h3 id="修改视图定义"><a href="#修改视图定义" class="headerlink" title="修改视图定义"></a>修改视图定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view view_name [column_list]</span><br><span class="line">as select_statement</span><br><span class="line">[with [cascaded | local] check option]</span><br></pre></td></tr></table></figure>

<h3 id="删除视图定义"><a href="#删除视图定义" class="headerlink" title="删除视图定义"></a>删除视图定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view [if exists]</span><br><span class="line">view_name1[,view_name2,...,view_namen]</span><br></pre></td></tr></table></figure>

<p>查看视图定义<br><code>show create view view_name \G</code></p>
<h3 id="更新视图定义"><a href="#更新视图定义" class="headerlink" title="更新视图定义"></a>更新视图定义</h3><p>当视图有以下情况时不可更新</p>
<ul>
<li>聚合函数</li>
<li>distinct 关键字</li>
<li>group by子句。</li>
<li>order by子句。</li>
<li>having子句</li>
<li>union子句。</li>
<li>位于选择列表的子查询.</li>
<li>from子句中包含多个表</li>
<li>select语句中引用了不可更新视图。</li>
<li>where子句中的子查询，引用from子句中的表。</li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>概念<br>触发器是指被指定关联到一个表的数据库对象，当一个表的特定事件出现时，它将会被激活并执行相应的操作。<br>触发器保障数据库中数据的完整性，以及多个表之间的一致性。<br>触发器就是MySQL响应insert、update、delete语句而自动执行的一条MySQL语句(或位于begin和end语句之间的一组MySQL语句)。</p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create </span><br><span class="line">trigger trigger_name trigger_time trigger_event</span><br><span class="line">on tb_name for each row trigger_body;</span><br></pre></td></tr></table></figure>

<p>trigger_name:触发器名称<br>trigger_time:触发器被触发的时刻，有两个选项before和after。如果用于验证新数据是否满足限制使用before<br>trigger_event:触发事件，用于指定激活触发器的种类，其可以是下述值之一:<br>    (1).insert,load data<br>    (2).update<br>    (3).delete<br>tb_name:与触发器相关的表名，必须引用永久性表。同一个表不能有两个相同触发时刻和触发事件的触发器。如两个after update触发器。<br>for each row:指定对于受触发事件影响的每一行都要激活触发器的动作。如插入多行数据，每一行都会执行触发器动作。<br>trigger_body:触发器动作主体，可以使用begin…end语句。每个表最多只能有6个触发器。</p>
<p>查看已有的触发器</p>
<p><code>show triggers [{from | in} db_name];</code></p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><code>drop trigger [if exists] [schema_name.] trigger_name;</code><br>schema_name:数据库名</p>
<h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><p> (1).insert触发器<br>    insert触发器可引用一个new表访问被插入的行，new表中的值可以被更新。<br>    对于auto_increment列，在触发器执行后将包含新的自动生成值。<br> (2).delete触发器<br>    delete触发器可以引用一个old表访问被删除的行，该表不可更新。<br> (3).update触发器<br>    update触发器可以引用new表和old表。<br>    当触发器涉及对表自身的更新操作时，只能使用before update触发器</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>在指定时刻执行某些特定任务就是事件。<br>        使用事件必须打开event_scheduler<br>打开event_scheduler的方法<br> (1).set global event_scheduler=1;<br> (2).set @@event_scheduler=1;<br>查看event_scheduler是否打开<br> <code>select @@event_scheduler;</code><br> <code>show variable like &#39;event_scheduler&#39;;</code></p>
<h3 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h3><p>create<br>event<br>[if not exists]<br>event_name<br>on schedule schedule<br>[enable | disable | disable on slave]<br>do event body<br>schedule的格式<br>at timestamp[+interval interval]…]<br>| every interval<br>[starts timestamp [+ interval interval]…]<br>[ends timestamp [+ interval interval]…]</p>
<p>interval的格式<br>quantity {year | quarter | month | day<br>| hour | minute| week | second<br>| year_month | day_hour | day_minute | day_second<br>| hour_minute | hour_second | minute_second}</p>
<p>event_name:事件名字<br>at子句:指定事件在某一刻发生。timestamp表示一个具体的时间点。quantity是间隔时间的数值<br>every子句:指定事件多久发生一次。starts表示开始时间，ends表示结束时间。<br>event_body：事件的动作体，可以使用begin…end语句<br>enable | disable | disable on slave:表示事件的状态,enable表示活动，disable表示关闭的，disable on slave表示在从机中是关闭的。</p>
<h3 id="修改事件"><a href="#修改事件" class="headerlink" title="修改事件"></a>修改事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter </span><br><span class="line">event event_name</span><br><span class="line">[ on schedule schedule]</span><br><span class="line">[rename to new new_event_name\</span><br><span class="line">[enable | disable | disable on slave]</span><br><span class="line">[do event_body]</span><br></pre></td></tr></table></figure>



<h3 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h3><p><code>drop event [if exists] event_name;</code></p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是一组为了完成某特定功能的SQL语句集，其实实质上就是一段存放在数据库中的代码。</p>
<p>它可以由声明式的SQL语句(如CREATE、UPDATE、SELECT等语句)和过程式SQL语句(如IF-THEN-ELSE控制结构语句)组成。</p>
<p>存储过程的优点:</p>
<ul>
<li>可增强SQL语言的功能和灵活性。存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li>
<li>良好的封装性。</li>
<li>高性能</li>
<li>可减少网络流量</li>
<li>存储过程可作为一种安全机制来确保数据库的安全性和数据的完整性。</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">PROCEDURE SP_NAME([PROC_PARAMETER[...]])</span><br><span class="line">[CHARACTERISTIC...]ROUTINE_BODY</span><br></pre></td></tr></table></figure>

<p>PROC_PARAMETER的格式:</p>
<p>[in| out | inout] param_name type</p>
<p>type的格式:</p>
<p>mysql所有有效的数据类型。</p>
<p>characteristic的格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMENT &apos;string&apos;</span><br><span class="line">| LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMIISTIC</span><br><span class="line">| &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125;</span><br><span class="line">| SQL_SECURITY &#123;DEFINER | INVOKER&#125;</span><br></pre></td></tr></table></figure>

<p>runtine_body的格式:</p>
<p>有效的SQL语句(集)</p>
<p>说明</p>
<ul>
<li><p>sp_name:存储过程名，如果创建的存储过程作用于别的数据库，则在存储过程名前加上数据库限定。</p>
</li>
<li><p>proc_parameter:存储过程的参数列表。in:输入参数 out:输出参数 inout:输入/输出参数。避免参数名和表的字段名相同。</p>
</li>
<li><p>characteristic</p>
<p>​    ① COMENT ‘string’:用于对存储过程的描述。该描述可以通过SHOW CREATE PROCEDURE来显示。</p>
<p>​    ② LANGUAGE SQL:指明编写这个存储过程的语言为SQL语言。</p>
<p>​    ③ DETERMINISTIC:如果设置为DETERMINISTIC，表示存储过程的对同样的参数返回同样的结果。如果设置 </p>
<p>​         为NOT DETERMINISTIC，表示同样的参数不一定返回同样的结果。</p>
<p>​    ④ CONTAINS SQL | NO SQL | READS SQL | MODIFIES SQL DATA:CONTAINS SQL表示存储过程包含读或 </p>
<p>​         或写的SQL语句，NO SQL表示存储过程不包含SQL语句，READS SQL DATA表示存储过程包含只读的SQ</p>
<p>​         L语句，MODIFIES SQL DATA表示存储过程包含写数据的SQL语句。</p>
</li>
<li><p>routine_body:存储过程的主体部分。即存储过程体。</p>
</li>
</ul>
<p><strong>DELIMITER</strong></p>
<p>更换语句结束符</p>
<p>例:</p>
<p>delimiter $$</p>
<p>此时结束符变为$$</p>
<h3 id="储存过程体"><a href="#储存过程体" class="headerlink" title="储存过程体"></a>储存过程体</h3><ol>
<li><p>局部变量</p>
<p><code>decare var_name[,...]type[default value]</code></p>
<p>var_name:变量名</p>
<p>type:变量数据类型</p>
<p>default:为变量指定默认值。没有指定默认为NULL。</p>
<p>说明:</p>
<ul>
<li>局部变量只能在存储过程的BEGIN…END语句中声明。</li>
<li>局部变量必须在存储过程体的开头处声明。</li>
<li>局部变量的作用范围仅限于声明它的BEGIN…END语句块，其他语句块中的不可以使用它</li>
<li>局部变量不同于用户变量，区别:用户变量定义时用@标识，用户变量的作用范围是整个会话中。</li>
</ul>
</li>
<li><p>SET语句</p>
<p>可以通过set语句为变量赋值。</p>
<p><code>set var_name=expr[,var_name=expr]...</code></p>
</li>
<li><p>SELECT…INTO语句</p>
<p>select…into语句可以将结果集中的数据赋值变量。</p>
<p><code>select col_name[...]into var _name[...] table_expr</code></p>
<p><strong>注意:</strong></p>
<p>select…into语句返回的结果只能是一行。</p>
</li>
<li><p>流程控制语句</p>
<ol>
<li><p>条件控制语句</p>
<p>常用的条件判断语句有IF-THEN-ELSE语句和CASE语句。</p>
<p>IF-THEN-ELSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF search_condition THEN statement_list</span><br><span class="line">[ELSEIF search_condition THEN statement_list]...</span><br><span class="line">[ELSE statement_list]</span><br><span class="line">ELSE IF</span><br></pre></td></tr></table></figure>

<p>如果使用的是<code>ELSEIF</code>可以使用end if就结束该语句。</p>
<p>如果使用的是<code>ELSE IF</code>则需要每一个if使用一个end if。</p>
<p>CASE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">	WHEN when_value THEN statement_list</span><br><span class="line">	[WHEN when_value THEN statement_list]</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END CASE</span><br></pre></td></tr></table></figure>

<p>或:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE </span><br><span class="line">	[WHEN search_condition THEN statement_list]</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END CASE</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环语句</p>
<p>常用的循环语句有WHILE语句，REPEAT语句和LOOP语句。</p>
<p>WHILE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:]WHILE search_condition DO</span><br><span class="line">	statement_list</span><br><span class="line">END WHILE[end_label]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>while循环先判断search_condition是否为真，倘若为真，则执行statement_list中的语句，然后再次执行判断，如果仍然为真则继续循环，直至条件判断不为真时结束循环。</p>
</li>
<li><p>begin_label和end_label是WHILE语句的标注，且必须使用相同的名字，并成对出现。</p>
</li>
</ul>
<p>REPEAT:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:]REPEAT</span><br><span class="line">	statement_list</span><br><span class="line">UNTIL serach_condition</span><br><span class="line">END REPEAT[end_label]</span><br></pre></td></tr></table></figure>

<ul>
<li>REPEAT语句先执行statement_list中的语句，然后判断search_condition是否为真，倘若为真则结束循环，如若不为真则继续循环。</li>
<li>WHILE 和 REPEAT的区别是WHILE先判断，条件为真就继续，REPEAT是先执行后判断，条件不为真就继续。</li>
</ul>
<p>LOOP:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:]LOOP</span><br><span class="line">	statement_list</span><br><span class="line">END LOOP[end_label]</span><br></pre></td></tr></table></figure>

<ul>
<li>在循环体statement_list中语句会一直重复执行，直至循环使用LEAVE语句退出。</li>
<li>LEAVE语句的格式:<code>LEAVE label</code>,这里的label是LOOP语句中自定义的名字，LEAVE是退出结束一个循环。</li>
<li>ITERATE语句，可以使用在LOOP,REPEAT,WHILE子句中，用于表示退出循环。只能结束一次循环，并不能退出当前循环。</li>
</ul>
</li>
</ol>
</li>
<li><p>游标</p>
<p>游标是一个被SELECT检索出来的结果集。</p>
<p><strong>注意</strong></p>
<ul>
<li>MySQL对游标的支持是从MySQL5.0开始的，之前的MySQL版本无法使用游标。</li>
<li>游标只能用于存储过程或存储函数中，不能单独在查询操作中使用。</li>
<li>在存储过程或存储函数中可以定义多个游标，但是在一个BEGIN…END语句块中每个游标的名字必须是唯一的。</li>
<li>游标不是一条SELECT语句，是被SELECT语句检索出来的结果集。</li>
</ul>
<h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><ul>
<li><p>声明游标</p>
<p><code>DECLARE cursor_name CURSOR FOR select_statement</code></p>
<p>cursor_name:游标名称</p>
<p>select_statement:指定一个SELECT语句，其返回一行或多行的数据。这里的SELECT语句不能有INTO子句。</p>
</li>
<li><p>打开游标</p>
<p>游标在声明后必须打开才能使用</p>
<p><code>OPEN cursor_name</code></p>
</li>
<li><p>读取数据</p>
<p><code>FETCH cursor_name INTO var_name[,var_name]...</code></p>
<p>cursor_name:指定已打开的游标</p>
<p>var_name:用于指定存放数据的变量名。</p>
<p>FETCH…INTO语句与SELECT…INTO语句具有相同的意义，FETCH语句是将游标指向的一行数据赋给一个变量，这些变量的数目必须等于声明游标时SELECT子句中选择列的数据。游标相当于一个指针，指向当前行的数据。</p>
</li>
<li><p>关闭游标</p>
<p>在结束游标使用后，必须关闭游标</p>
<p><code>CLOSE cursor_name</code></p>
<p>如果没有明确关闭游标，MySQL将会到达END语句时自动关闭它。</p>
</li>
</ul>
<p><strong>句柄</strong></p>
<p>句柄可以移动游标。</p>
<p>`DECLARE CONTINUE HANDLER FOR NOT FOUND</p>
<p>如果没有数据就将found设置为false;</p>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">zmpl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/12/15/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/">http://yoursite.com/2019/12/15/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/12/11/jQuery%E7%AC%94%E8%AE%B0/"><span>jQuery笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(images/index.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By zmpl</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.0"></script><script src="/js/fancybox.js?version=1.6.0"></script><script src="/js/sidebar.js?version=1.6.0"></script><script src="/js/copy.js?version=1.6.0"></script><script src="/js/fireworks.js?version=1.6.0"></script><script src="/js/transition.js?version=1.6.0"></script><script src="/js/scroll.js?version=1.6.0"></script><script src="/js/head.js?version=1.6.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>