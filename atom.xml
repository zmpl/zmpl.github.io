<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zmpl&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-15T03:50:56.541Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zmpl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据库总结</title>
    <link href="http://yoursite.com/2019/12/15/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/15/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-15T03:50:56.541Z</published>
    <updated>2019-12-15T03:50:56.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库总结"><a href="#MySQL数据库总结" class="headerlink" title="MySQL数据库总结"></a>MySQL数据库总结</h1><h3 id="数据库的常见问题"><a href="#数据库的常见问题" class="headerlink" title="数据库的常见问题"></a>数据库的常见问题</h3><ol><li><p>数据库的默认端口:3306<br>常见名词:<br>DB:数据库<br>DBS:数据库系统<br>DBMS:数据库管理系统<br>DBMA:数据库管理人员</p></li><li><p>sql的功能:<br>DDL:数据定义功能 CREATE  、ALTER、DROP<br>DBML:数据操纵功能 SELECT、insert、update、delete<br>mDCL:数据控制功能 安全管理 grant、revoke</p></li><li><p>数据库使用的语言: 结构化查询语言sql</p></li><li><p>常量:<br>字符串常量、数值常量、十六进制常量、日期时间常量、位字段值、布尔值、NULL值</p></li><li><p>变量:<br>用户变量:<br>   <code>@one</code><br>系统变量:<br>  <code>@@two</code>    </p></li></ol><ol start="7"><li>运算符:<br>  <code>&#39;+&#39; &#39;-&#39; &#39;*&#39; &#39;/&#39; &#39;%&#39;</code><br>  <code>&#39;&amp;&#39; &#39;|&#39; &#39;^&#39; &#39;~&#39; &#39;&gt;&gt;&#39; &#39;&lt;&lt;&#39;</code><br>  <code>&#39;=&#39; &#39;&gt;=&#39; &#39;&lt;=&#39; &#39;&gt;&#39; &#39;&lt;&#39; &#39;!=&#39; &#39;&lt;&gt;&#39; &#39;&lt;=&gt;&#39;</code>(相等或都等于空)</li><li>常用内置函数:<br>数学函数:<code>abs(),sqrt(),floor(),rand(),truncate()</code>,<br>聚合函数: <code>COUNT(),sum(),avg(),max(),min()</code>,<br>字符串函数: <code>ASCii(),char(),substring(),concat(),upper(),ucase(),lower(),left()</code>,<br>日期和时间函数: <code>now(),year(),month(),day(),curdate(),current_date(),curtime(),current_time()</code>,<br>加密函数: <code>encode(),encrypt()</code>,<br>控制流程函数: <code>if(),ifNULL()</code>,<br>格式化函数: <code>format()</code>,<br>类型转换函数:<code>case()</code>,<br>系统信息函数: <code>user(),version()</code>,</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>数据库的创建:<br><code>CREATE   database | schema db_name;</code><br>db_name的命名规则:可以是0-9,26个英文字母和’_’ ‘#’组成,不能是数据库中的关键字或保留字<br>创建的时候指定默认字符集和默认校对规则</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   database | schema db_name;</span><br><span class="line">     default character set 字符集名称</span><br><span class="line">     default collate 校对规则名称;</span><br></pre></td></tr></table></figure><p>常用字符集:<code>utf8 gb2312 gbk</code><br>常用校对规则 <code>utf8_general_ci gb2312_chinese_ci gbk_chinese_ci</code></p></li><li><p>数据库的修改<br>修改数据库的默认字符集和默认校对规则</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER database | schema db_name</span><br><span class="line"> default character set 字符集名称</span><br><span class="line"> default collate 校对规则名称;</span><br></pre></td></tr></table></figure></li><li><p>数据库的删除<br><code>DROP database | schema db_name;</code></p></li><li><p>选择数据库<br><code>use db_name;</code></p></li><li><p>关于数据库的一些信息查询<br>查看当前选择的数据库<br>  <code>SELECT database() | schema();</code><br>查看mysql中所有的的数据库<br>  <code>show database | schemas;</code><br>查看mysql中支持的字符集和与字符集对应的默认校对规则<br>   <code>show charset;</code><br>查看mysql中支持的校对规则<br>   <code>show collation;</code><br>查看默认字符集<br>   <code>show variables like &#39;character%&#39;;</code><br>查看默认校对规则<br>   <code>show variables like &#39;collation%&#39;;</code><br>查看mysql支持的存储引擎<br>   <code>show engines;</code><br>查看当前登录的用户<br>  <code>SELECT user();</code><br>查看mysql的版本<br>  <code>SELECT version();</code></p></li></ol><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><ol><li><p>表的创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE tb_name</span><br><span class="line">(   </span><br><span class="line">    col_name1 INT,</span><br><span class="line">    col_name2 char(20),</span><br><span class="line">    col_name3 VARCHAR(20),</span><br><span class="line">    col_name4 float(7),</span><br><span class="line">   ......</span><br><span class="line">)engine=engine_name;</span><br></pre></td></tr></table></figure><p>tb_name的命名规则和数据库名一样<br>字符的数据类型可以是:<br><code>bit,tinyINT,smALLINT,mediumINT,INT,INTeger,bigINT</code><br><code>real,double,float,decimal,numeric</code> 表示指定精度的浮点型数值<br><code>date,time,timestamp,datetime</code><br><code>char,VARCHAR,text,tinytext</code><br><code>blob,mediumblobm,longblob,tinytext,text,mediumtext,longtext</code><br><code>enum(value1,value2,value3,...)</code><br><code>set(value1,value2,value3,value4,value5)</code></p></li><li><p>自增属性:auto_increment 只能定义在INT类型上 自动增长的功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT auto_increment PRIMARY KEY,</span><br><span class="line">  testname VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>修改表<br> ALTER后面可以跟上多个MODIFY,change子句,子句之间用逗号隔开<br> <strong>添加字段</strong><br> 添加在所有字段前面<br>  <code>ALTER TABLE test add testno INT first;</code><br> 添加在某个字段后面<br>  <code>ALTER TABLE test add testno INT after col_name;</code><br> <strong>修改字段</strong><br> 修改数据类型,字段位置<br><code>ALTER TABLE tb_name MODIFY testno char(20) after col_name;</code><br>修改字段名,字段位置,数据类型<br><code>ALTER TABLE tb_name changes testno tno INT after col_name;</code><br>修改字段默认值<br><code>ALTER TABLE tb_name ALTER [column] testno set default &#39;1&#39;;</code><br><strong>删除字段</strong><br><code>ALTER TABLE tb_name DROP col_name;</code><br><strong>重命名表</strong><br>方法1:<br><code>ALTER TABLE old_tb_name rename to new_tb_name;</code><br>方法2:<br><code>rename TABLE old_tb_name to new_tb_name</code>;<br>修改多个表名<br><code>rename TABLE old_tb_name to new_tb_name,old2_tb_name to new2_tb_name,......;</code><br> <strong>删除表</strong><br> <code>DROP TABLE tb_name;</code><br> <strong>查看表的相关信息</strong><br>查看当前库某个表的结构<br> <code>DESC tb_name;</code><br> <code>show columns FROM | in tb_name;</code><br>查看某个库某个表的结构<br>  <code>show columns FROM | in tb_name FROM | INT db_name;</code><br>查看当前库某个表的详细结构<br>   <code>show CREATE   TABLE tb_name \g | \G</code>  –&gt; \g的作用是以列表的形式查询内容 \g是以表格的形式查看内容</p></li><li><p>实体完整性约束<br>主键约束:<code>PRIMARY KEY</code><br>表级创建语法:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT,   # -- &gt;&gt;&gt;INT默认长度11</span><br><span class="line">  testname VARCHAR(20),</span><br><span class="line">   CONSTRAINT test_pr PRIMARY KEY(testno)  #-- &gt;&gt;&gt;主键可以自定义名,但是定义无效</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p>   列级创建语法:<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT PRIMARY KEY,</span><br><span class="line">  testname VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>   一个表中只能存在一个主键,主键可以定义在多列上形成复合主键。<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">  testno INT,</span><br><span class="line">  testname VARCHAR(20),</span><br><span class="line">  testnum INT,</span><br><span class="line">  PRIMARY KEY(testno,testnum)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>   定义主键的时候同时会增加一个主键索引<br>   定义的主键上不能出现空值</p><p>   <code>ALTER TABLE</code>的方式对已存在的表添加主键:<br>   <code>ALTER TABLE test add CONSTRAINT test_pr PRIMARY KEY(test);</code><br>   添加复合主键的方式与添加主键的方式相同<br>   <code>ALTER TABLE test add CONSTRAINT test_pr PRIMARY KEY(test,test2,...);</code></p><p>  候选键约束:UNIQUE KEY<br>  候选键又称唯一约束,候选键的值必须是唯一的,并且不能为空<br>   表级创建语法<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">testno INT,</span><br><span class="line">testname VARCHAR(20),</span><br><span class="line">testnum INT,</span><br><span class="line">CONSTRAINT uk_tno UNIQUE KEY(testno),</span><br><span class="line">CONSTRAINT uk_tname_tnum UNIQUE KEY(testname,testnum)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>   列级创建语法<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test</span><br><span class="line">(</span><br><span class="line">testno INT UNIQUE KEY,</span><br><span class="line">   testname VARCHAR(20) UNIQUE KEY,</span><br><span class="line">   testnum INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>  删除候选键约束:<br>    <code>ALTER TABLE test DROP index uk_name;</code> –&gt;<code>uk_name</code>:候选键约束名<br>  或 <code>DROP index uk_name on test;</code></p><ol start="5"><li><p>参照性约束<br> 参照完整性规则定义的是外键与主键之间的引用规则,即外键的取值或为空,或者等于被参照关系中某个主键的值。<br> 定义外键的规则:</p><ul><li><p>被参照表必须已创建或者正在创建,被参照表是正在创建的表那参照表也是正在创建的表</p></li><li><p>被参表必须定义主键或候选键</p></li><li><p>必须在被参表的表名后面指定列名或列名的组合，这个列或列组合必须是被参照表的主键或候选键</p></li><li><p>主键不能包含空值,但允许在外键中出现空值.这意味着只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的</p></li><li><p>外键对应列的数目必须和参照表的主键对应列的数目相同</p></li><li><p>外键对应列的数据类型必须和被参照表的主键对应列的数据类型相同</p></li><li><p>外键只能定义在主键或候选键上</p></li><li><p>外键只能定义在<code>innodb</code>表上</p></li></ul><p>表级创建语法:</p><p>被参照表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test1</span><br><span class="line">(</span><br><span class="line">   testno INT PRIMARY KEY,</span><br><span class="line">   testname VARCHAR(20),</span><br><span class="line">   testnum INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参照表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE   TABLE test2</span><br><span class="line">(</span><br><span class="line">   testno INT,</span><br><span class="line">   testname VARCHAR(20),</span><br><span class="line">   testnum INT,</span><br><span class="line">   CONSTRAINT fk_tno FOREIGN KEY(testno) references test1(testno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>关闭外键检查</p><pre><code>`set foreign_key_checks=0;`</code></pre><p>开启外键检查</p><pre><code>`set foreign_key_checks=1;`</code></pre></li><li><p>用户定义的完整性约束</p><p>非空约束:指字段值不能为空</p><p>创建语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. CREATE   TABLE</span><br><span class="line">   CREATE   TABLE test</span><br><span class="line">   (</span><br><span class="line">      testno INT NOT NULL UNIQUE KEY,</span><br><span class="line">      testname VARCHAR(20) UNIQUE KEY,</span><br><span class="line">      testnum INT</span><br><span class="line">   );</span><br><span class="line">2. ALTER TABLE</span><br><span class="line">   ALTER TABLE test MODIFY testno INT NOT NULL;</span><br><span class="line">      </span><br><span class="line">   ALTER TABLE test change testno tno INT NOT NULL;</span><br></pre></td></tr></table></figure><p>默认值约束</p><p>创建语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. CREATE   TABLE</span><br><span class="line">   CREATE   TABLE test</span><br><span class="line">   (</span><br><span class="line">      testno INT default &apos;1&apos; UNIQUE KEY,</span><br><span class="line">      testname VARCHAR(20) UNIQUE KEY,</span><br><span class="line">      testnum INT</span><br><span class="line">   );</span><br><span class="line">2. ALTER TABLE</span><br><span class="line">   ALTER TABLE test MODIFY testno INT default &apos;1&apos;;</span><br><span class="line">      </span><br><span class="line">   ALTER TABLE test change testno tno default &apos;1&apos;;</span><br></pre></td></tr></table></figure><p>更新约束:</p><p>添加约束:</p><p><code>ALTER TABLE test add [CONSTRAINT] {FOREIGN KEY | PRIMARY KEY | UNIQUE KEY}(col_name,col2_name,......);</code></p><p>删除外键约束:</p><p><code>ALTER TABLE test DROP FOREIGN KEY fk_name;</code>  –&gt; fk_name: 外键约束名</p></li></ol><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [ALL|distinct|distinctrow] &lt;目标列表达式1&gt; [,&lt;目标列表达式2&gt;]...</span><br><span class="line">FROM &lt;表名1或视图1&gt; [,表名2或视图名2]...</span><br><span class="line">[WHERE &lt;条件表达式&gt;]</span><br><span class="line">[GROUP BY &lt;列名 1&gt; [HAING &lt;条件表达式&gt;]]</span><br><span class="line">[ORDER BY &lt;列名1&gt; [ASC|DESC]]</span><br><span class="line">[LIMIT [m,]n];</span><br></pre></td></tr></table></figure><p>查询表中所有数据包括重复行(默认包括重复行）<br><code>SELECT ALL * FROM test;</code><br>查看表中所有数据不包括重复行<br><code>SELECT distinct * FROM test;</code><br>查看某个列<br><code>SELECT col_name FROM test;</code><br>查看多个列用’,’号隔开<br><code>SELECT col_name1,col_name2,...,col_nameN FROM test;</code><br>查看所有列|字段<br><code>SELECT *|ALL col_name FROM test;</code><br>条件查询<br>比较: =,&lt;&gt;,!=,&lt;,&lt;=,&gt;,&gt;=,!&lt;,!&gt;,NOT+含比较运算符的表达式<br>确定范围:<code>between and,NOT between and</code><br>确定集合:<code>in,NOT in</code><br>字符匹配:<code>like,NOT like</code><br>空值:<code>is NULL,is NOT NULL</code><br>多重条件:<code>and,or</code> </p><p>例子:<br>查询score表中分数&gt;60的相关信息<br><code>SELECT * FROM score WHERE grade&gt;60;</code><br>查询student中籍贯不是江西的所有信息<br><code>SELECT * FROM student WHERE native!=&#39;江西&#39;;</code><br>查询score表中分数在60-80的相关信息<br><code>SELECT * FROM score WHERE grade between 60 and 80;</code><br>查询score中分数不在60-80的相关信息<br><code>SELECT * FROM score WHERE grade NOT between 60 and 80;</code><br>查看籍贯是上海,深圳,香港的学生信息<br><code>SELECT * form student WHERE native in(&#39;上海&#39;,&#39;深圳&#39;,&#39;香港&#39;);</code><br>查看籍贯不是上海,深圳,香港的学生信息<br><code>SELECT * FROM student WHERE native NOT in(&#39;上海&#39;,&#39;深圳&#39;,&#39;香港&#39;);</code><br>查看姓名中有’明’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;%明%&#39;;</code><br>查看姓’张’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;张%&#39;;</code><br>查看姓名中最后一个字为’恒’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;%恒&#39;;</code><br>查看名字为3个字且以’刘’开头的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;刘__&#39;</code><br>查看名字为3个字且第二个字为’空’的学生信息<br><code>SELECT * FROM student WHERE studentname like &#39;_空_&#39;;</code><br>查看名字为3个字且第三个字为’浪’的学生信息<br><code>SELECT * FROM student whee studentname like &#39;__浪&#39;;</code><br>查看手机号码为空的学生信息<br><code>SELECT * FROM student WHERE phonenumber is NULL;</code><br>查看手机号码不为空的学生信息<br><code>SELECT * FROM student WHERE phonenumber is NOT NULL;</code><br>查看性别为男且有手机号码的学生信息<br><code>SELECT * FROM student WHERE sex=&#39;男&#39; and phonenumber is NOT NULL;</code><br>查看民族是汉族或其他民族的学生信息<br><code>SELECT * FROM student WHERE nation=&#39;汉&#39; or nation=&#39;壮&#39;;</code></p><h4 id="正则表达式查询"><a href="#正则表达式查询" class="headerlink" title="正则表达式查询"></a>正则表达式查询</h4><p>[NOT][regexp][rlike] &lt;正则表达式&gt;<br>规则:</p><table><thead><tr><th align="center">选项</th><th align="center">说明</th><th align="center">例子</th><th align="center">匹配值示例</th></tr></thead><tbody><tr><td align="center">&lt;字符串&gt;</td><td align="center">匹配包含指定字符串的文本</td><td align="center">‘fa’</td><td align="center">fan,afa,faad</td></tr><tr><td align="center">[]</td><td align="center">匹配[]中的任何一个字符</td><td align="center">‘[ab]’</td><td align="center">bay,big,app</td></tr><tr><td align="center">[^]</td><td align="center">匹配不在[]中的任何一个字符</td><td align="center">‘[^ab]’</td><td align="center">desk,cool,six</td></tr><tr><td align="center">^</td><td align="center">匹配文本的开始字符</td><td align="center">‘^b’</td><td align="center">bed,brige,book</td></tr><tr><td align="center">$</td><td align="center">匹配文本的结尾字符</td><td align="center">‘er$’</td><td align="center">driver,worker,farmer</td></tr><tr><td align="center">.</td><td align="center">匹配任意单个字符</td><td align="center">‘b.t’</td><td align="center">better,bit,bite</td></tr><tr><td align="center">*</td><td align="center">匹配0个或多个*前面指定的字符</td><td align="center">‘f*n’</td><td align="center">fn,fan,begin</td></tr><tr><td align="center">+</td><td align="center">匹配+前面的字符1次或多次</td><td align="center">‘ba+’</td><td align="center">bat,baa,battle,bala</td></tr><tr><td align="center">{n}</td><td align="center">匹配前面的字符至少n次</td><td align="center">‘b{2}’</td><td align="center">bb,bbbb,bbbbbbb</td></tr></tbody></table><p>例子:</p><p>查看出版社名称中带’教育’的图书信息<br><code>SELECT * FROM tb_book WHERE publisher regexp &#39;教育&#39;;</code><br>查看图书名称中带’p’或’m’的图书信息<br><code>SELECT * FROM tb_book WHERE bname regexp &#39;[pm]&#39;;</code><br>查看图书名称中不带’高’的图书信息<br><code>SELECT * FROM tb_book WHERE bname NOT regexp &#39;高&#39;;</code><br>查看班级号以’A’开头的成绩信息<br><code>SELECT * FROM score WHERE c_no regexp &#39;^A&#39;;</code><br>查看学号中包含’2’和’4’的成绩信息<br><code>SELECT * FROM score WHERE s_no regexp &#39;2*4&#39;;</code><br>查看班级号以’1’结尾的成绩信息<br><code>SELECT * FROM score WHERE c_no regexp &#39;1$&#39;;</code><br>查看学号中包含’08’的成绩信息<br><code>SELECT * FROM score WHERE s_no regexp &#39;08+&#39;;</code><br>查看学号中包含’23’的成绩信息<br><code>SELECT * FROM score WHERE s_no regexp &#39;23{1}&#39;;</code></p><p>空值查询</p><p>空值一般表示数据未知、不确定或以后再添加,空值不等同于0,也不同于空字符串。<br>    判断字段内容是否为空不能用’=’<br>判断空值使用 IS NULL<br><code>SELECT * FROM tb_course WHERE priorCourse is null;</code><br>判断字段内容不为空<br><code>SELECT * FROM tb_course WHERE priorCourse is not null;</code></p><p>对查询结果排序</p><p><code>ORDER BY col_name[,col2_name,...][ASC | DESC];</code>  –&gt; ORDER BY子句放在WHERE子句之后<br>查询tb_student表中学生的信息并按姓名升序排列<br><code>SELECT * FROM tb_student ORDER BY studentName[ASC];</code>   –&gt; 排序默认升序<br>查询tb_score表中学生的成绩信息并按成绩降序排序<br><code>SELECT * FROM tb_score ORDER BY score DESC</code><br>对多个字段排序<br>查询tb_score表中的成绩信息并按学号升序排序再按成绩降序排序<br><code>SELECT * FROM tb_score ORDER BY studentNo ASC,score DESC;</code><br>查询tb_student表中学生的信息并按姓名降序排列再按班级号升序排列<br><code>SELECT * FROM tb_student ORDER BY studentName DESC,classNo ASC;</code></p><p>限制查询结果的数量</p><p>LIMIT [位置偏移量] 行数   –&gt; 位置偏移量是指相对于第一行这个位置偏移了多少行<br>                                            –&gt; LIMIT子句放在ORDER BY 子句之后<br>查询tb_score表中学生的成绩信息并按成绩降序排序,只查看前3名<br><code>SELECT * FROM tb_score ORDER BY score DESC limit 0,3;</code><br>LIMIT 行数 OFFSET 位置偏移量<br>查询tb_score表中学生的成绩并按成绩升序排列,只看倒数3名<br><code>SELECT * FROM tb_score ORDER BY score ASC limit 3 OFFSET 0;</code></p><h4 id="分组聚合查询"><a href="#分组聚合查询" class="headerlink" title="分组聚合查询"></a>分组聚合查询</h4><p>GROUP BY<br>聚合函数:<code>COUNT(*)</code>                    –&gt; 统计数据表中的记录数<br><code>COUNT(col_name)</code>                        –&gt; 统计一列中值的个数<br><code>MAX(col_name)</code>                        –&gt; 求一列中值的最大值<br><code>MIN(col_name)</code>                        –&gt; 求一列中值的最小值<br><code>SUM(col_name)</code>                        –&gt; 求一列中值的总和<br><code>AVG(col_name)</code>3 c   s                        –&gt; 求一列中值的平均值<br>除COUNT(*)外其它聚合函数包括COUNT(col_name)都会忽略空值                                      </p><p>聚合查询例子  </p><p>查询tb_student表中学生的总数<br><code>SELECT COUNT(*) FROM tb_student;</code><br>查询tb_student表中学生的总数,给字段取别名学生总数<br><code>SELECT COUNT(*) 学生总数 FROM tb_student;</code>   –&gt; 字段名后面空一格加上别名<br>或<br><code>SELECT COUNT(*) AS 学生总数 FROM tb_student;</code>    –&gt; 字段名后面空一格加上AS 别名<br>查询tb_score中选了课的学生总数并以别名的形式输出<br><code>SELECT COUNT(DISTINCT studentNo) AS 学生总数 FROM tb_score;</code><br>查询tb_score中成绩最高的学生的成绩信息<br><code>SELECT * FROM tb_score WHERE score=(SELECT MAX(score) FROM tb_score);</code><br>查询tb_score中最低的成绩<br><code>SELECT MIN(score) FROM tb_score;</code><br>查询tb_score表中成绩的平均值<br><code>SELECT AVG(SCORE) FROM tb_score;</code><br>查询tb_score表中所有成绩的总和<br><code>SELECT SUM(score) FROM tb_score;</code>                                                            </p><p>分组聚合查询例子</p><p>查询tb_student表中每个班级的总人数<br><code>SELECT classNo,COUNT(*) FROM tb_student GROUP BY classNo;</code><br>查询每个课程的学生平均成绩<br><code>SELECT courseNo,AVG(score) FROM tb_score GROUP BY courseNo;</code><br>查询每个学生的选课数,平均分,最高分<br><code>SELECT studentNo,COUNT(*) 选课数,AVG(SCORE) 平均分,MAX(score) 最高分 FROM tb_score GROUP BY studentNo;</code><br>查询有2门以上(含2门)课程成绩大于88分的学生学号及(88分以上的)课程数<br><code>SELECT studentNo,COUNT(*) 课程数 FROM tb_score WHERE score&gt;88 GROUP BY studentNo having COUNT(*)&gt;=2;</code><br>查询所有学生选课的平均成绩,但只有当平均成绩大于80的情况下才输出<br><code>SELECT AVG(score) AS 别名 FROM tb_score HAVING AVG(score)&gt;80;</code>    –&gt; HAVING短语在数据分组后进行过滤,WHERE短语在数据分组前进行过滤<br> –&gt; HAVING短语没有接GROUP BY短语会将所有记录分在一个组<br>–&gt; 示例待补充…</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>交叉连接<br>CROSS JOIN 又称笛卡尔积,即把每一张表的每一行与另一张表的每一行连接起来,返回两张表的每一行相连接后所有可能的结果<br>语法:<br>SELECT * FROM 表1 CROSS JOIN 表2;<br>或<br>SELECT * FROM 表1,表2;<br>因为返回的查询结果集等于两张表记录行数的乘积,所以交叉连接的结果集会非常庞大,且查询执行时间特别长,甚至有可能因为返回的数据过多而造成系统的停滞不前,因此对于存在大量数据的表,应避免使用交叉连接。</p><p>例子:<br>查询tb_student和tb_score表的所有可能结果<br>SELECT * FROM tb_student CROSS JOIN tb_score; </p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>INNER JOIN 通过在查询中设置连接条件来移除交叉连接查询的结果集中某些数据行。<br>语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表1 INNER JOIN 表2 INNER JOIN 表3        </span><br><span class="line">ON 连接条件</span><br><span class="line">[WHERE 过滤条件];--&gt; 字段列表里可以是要检索的字段名或者是别名</span><br><span class="line">或使用WHERE子句定义连接条件的隐式语法结构</span><br><span class="line">SELECT * FROM 表1,表2 WHERE 连接条件 [AND 过滤条件];        --&gt; 字段列表里可以是要检索的字段名或者是别名</span><br></pre></td></tr></table></figure><p>等值与非等值连接<br>[&lt;表明1&gt;.]&lt;字段名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;字段名2&gt;<br>其中比较运算符主要要:=,&gt;,&lt;,&gt;=,&lt;=,!=(&lt;&gt;).当比较运算符为’=’时表示等值连接<br>例子:<br>查询每个学生的信息和成绩信息<br><code>SELECT * FROM tb_student t,tb_score e where t.studentNo=e.studentNo;</code><br>自连接<br>若某个表与自身进行连接,称为自表连接或自身连接,简称自连接.使用自连接时,需要为表指定多个不同的别名,且对所有查询字段的引用必须使用表别名限定,否则SELECT操作会失败</p><p>例子:<br>查询与’数据库’这门课学分相同的课程信息<br><code>SELECT c1.* FROM tb_course c1,tb_course c2 WHERE c1.credit=c2.credit and c2.courseName=&#39;数据库&#39; AND c1.courseName!=&#39;数据库&#39;;</code><br>自然连接<br>NATURAL JOIN 只用当连接字段在两张表的字段都相同时才可使用,否则返回的是笛卡尔积的结果集。</p><p>例子:</p><p>查询每个学生的信息和选课情况</p><p><code>select * from tb_student natural join tb_score;</code></p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>左外连接<br>左外连接，也称左连接(LEFT OUTER JOIN 或 LEFT JOIN)，用于返回该关键字左边表(基表)的所有记录，并用这些记录与该关键字右边表(参考表)的记录进行匹配，如果左表的某些记录在右表中没有匹配的记录，就和右表中的”万能行”连接，即右表对应的字段值全部设置为NULL。    </p><p>例子:</p><p>林海同学加入时未选课。</p><p><code>select a.studentNo studentNo,studentName,sex,classNo,courseNo,score from tb_student a left outer join tb_score b on a.studentNo=b.studentNo;</code></p><p>使用LEFT OUTER JOIN用on指定连接条件。</p><p>使用LEFT JOIN可以用where也可以用on指定连接条件。<br>右外连接</p><p>右外连接，也称右连接(RIGHT OUTER JOIN 或RIGHT JOIN)，以右表为基表，其连接方法和左外连接完全一样。即返回右表的所有记录，并用这些记录与左边表(参考表)中的记录进行匹配，如果右表的某些记录在左表中没有匹配的记录，左表对应的字段全部被设置为NULL。 </p><p> 例子:</p><p><code>select score,b.studentNo studentNo,studentName,sex,classNo from tb_score b right outer join tb_student a on b.studentNo=a.studentNo;</code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询也称嵌套查询，是将一个查询语句嵌套在另一个查询语句的where子句或having短语中，前者被称为内层查询或子查询，后者被称为外层查询或父查询。在整个语句中，执行顺序是先进行子查询，然后将子查询的返回结果作为父查询的筛选条件。</p><ol><li><p>带in关键字的子查询</p><p>带in关键字的子查询，一般用于判断某个值是否在某个区间。</p><p><strong>注意:</strong>内层查询只返回一行数据咧。</p><p>例:</p><p>查询籍贯为上海或北京的学生信息</p><p><code>select * from tb_student where native in(select native from tb_student where native=&#39;上海&#39; || native=&#39;北京&#39;);</code></p></li><li><p>带比较运算符的子查询</p><p>带比较运算符的子查询，一般用于将某个字段值跟特定的值比较。</p><p><strong>注意:</strong>内层查询只能返回一个数据。</p><p>例:</p><p>查询班级为和江山同一个班的学生信息。</p><p><code>select * from tb_student where classNo=(select classNo from tb_student where studentName=&#39;江山&#39;) and studentName!=&#39;江山&#39;;</code></p></li><li><p>带exists关键字的子查询</p><p>exists的子查询是否有结果，有返回true否则返回false</p><p>not exists与exists意义相反。</p><p>not exists内可以继续使用not exists双重否定变肯定。</p><p>例:</p><p>查询没有选修31002的学生姓名</p><p><code>select studentName from tb_student a where not exists(select * from tb_score b where a.studentNo=b.studentNo and courseNo=&#39;31002&#39;);</code></p><p>查询选修了所有课的学生姓名</p><p><code>select studentName from tb_student a where not exists(select * from tb_course c where not exists(select * from tb_score b where a.studentNo=b.studentNo and courseNo=c.courseNo));</code></p></li></ol><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>   使用union关键字可以将来自多个select语句结果集合到一个结果集中。合并时，多个select子句中对应的字段数和数据类型必须相同。</p><p>   语法:</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT -FROM-WHERE</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT -FROM-WHERE</span><br><span class="line">[...UNION [ALL]]</span><br><span class="line">SELECT -FROM-WHERE]</span><br></pre></td></tr></table></figure><p>使用ALL关键字，执行的时候返回返回所有记录，包括重复的记录。</p><p>不适用ALL关键字，则会去掉重复记录，也不对结果进行自动排序。</p><p>例:</p><p>查询所有老师的姓名和学生的姓名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sname name from students</span><br><span class="line">union</span><br><span class="line">select tname from teachers;</span><br></pre></td></tr></table></figure><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p>插入完整的数据记录不省略字段名,可以部分/完整字段插入<br><code>insert into tb_name(column_list) values(value_list);</code>                    </p><p>省略字段名,只能是全部字段插入<br><code>insert into tb_name values(value_list);</code></p><p>同时插入多条数据记录,可以部分/完整字段插入<br><code>insert into tb_name(column_list) values(value_list1),(value_list2),...,(value_listn);</code></p><p>插入查询结果<br><code>insert into tb_name1(column_list1) select column_list2 from tb_name2 where condition;</code></p><p>使用replace语句插入数据<br>如果一个待插入的表中存在有primary key或unique约束，而待插入的数据行中包含与待插入表中数据行相同的    primary key或unique列值，那么insert语句将无法插入此行。这时只能用replace语句插入数据，replace语句    插入的数据会将原来相同的数据删除,从而保证新纪录能够正常插入。<br><code>replace into tb_name(column_list) values(value_list);</code></p><h3 id="数据更新-1"><a href="#数据更新-1" class="headerlink" title="数据更新"></a>数据更新</h3><p>修改特定表该字段所有数据记录<br><code>update tb_name set column1=value1,column2=value2,...,columnn=valuen;</code></p><p>修改特定表指定的数据记录<br><code>update tb_nameset column1=value1,column2=value2,...,columnn=valuenwhere conditions;</code></p><p>带子查询的修改<br><code>update tb_nameset column1=value1,column2=value2,...,columnn=valuenwhere column_name=(select column[,column1,...,columnn] from tb_name);</code></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除一个表所有数据<br><code>delete from tb_name;</code></p><p>清空表数据<br><code>truncate table tb_name;</code></p><p>删除指定表特定数据<br><code>delete from tb_name where conditions;</code></p><p>带子查询的删除<br><code>delete from tb_name where column_name in(select column[,column1,...,columnn] from tb_name);</code></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从一个或多个表或者视图中导出的表，它也包含一系列带有名称的的数据列和若干条数据行。</p><p>视图与真实表的区别:<br>(1).视图不是真实的表，是虚拟表，它的结构和数据是建立在数据库中真实表的查询基础上。<br>(2).视图不是以数据集的形式存储在数据库中，它所对应的数据实际上是存储在视图所引用的真实表。<br>(3).视图本身并不存储数据。<br>(4).集中分散数据。<br>(5).简化查询语句。<br>(6).重用SQL语句。<br>(7).保护数据安全。<br>(8).共享所需数据。<br>(9).更改数据格式</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [or replace] view view_name [column_list]</span><br><span class="line">as select_statement</span><br><span class="line">[with [cascaded | local] check option]</span><br></pre></td></tr></table></figure><p>or replace:如果视图已存在则替换存在的视图</p><p>view_name:视图名</p><p>column_list:视图每个列的名称，列名的数据必须等同于select语句检索出的结果数据集的列数。</p><p>select_statement:用于指定创建视图的select语句，给出视图的定义，它可用于查询多个基础表或源视图中相同的列名。</p><p><strong>注意</strong></p><p>(1).定义视图的用户除了要求被授予create view的权限外，还必须授予可以操作视图所涉及的基础表或其他视图的相关权限。    </p><p>(2).select语句不能包含from子句中的子查询。</p><p>(3).select语句不能引用系统变量或用于变量。</p><p>(4).select语句不能引用预处理语句参数。</p><p>(5).在select语句中引用的表或视图必须存在。但是在创建完视图后可以删除引用的表或视图。</p><p>(6).若select语句中引用的不是当前数据库的基础表或源视图时，需要在该表或视图前加上数据库的名称作为限定前缀。</p><p>(7).在由select语句构造的视图定义中，允许使用order by子句。但是如果从特定视图进行了选择，而该视图使用了自己的order by语句，则视图定义中的order by子句将被忽略。</p><p>(8).对于select语句中的其他选项或子句，若所创建的视图中包含了这些选项，则语句执行效果未定义。</p><p>with check option:用于指定在可更新视图上进行的修改都需要符合select_statement中所指定的限定条件。当视图引用另一个视图时，有两个参数:cascaded和local，它们决定检查测试的范围。<br>            cascaded是默认值，它会对所有视图进行检查，local只对定义的视图进行检查。</p><h3 id="修改视图定义"><a href="#修改视图定义" class="headerlink" title="修改视图定义"></a>修改视图定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view view_name [column_list]</span><br><span class="line">as select_statement</span><br><span class="line">[with [cascaded | local] check option]</span><br></pre></td></tr></table></figure><h3 id="删除视图定义"><a href="#删除视图定义" class="headerlink" title="删除视图定义"></a>删除视图定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view [if exists]</span><br><span class="line">view_name1[,view_name2,...,view_namen]</span><br></pre></td></tr></table></figure><p>查看视图定义<br><code>show create view view_name \G</code></p><h3 id="更新视图定义"><a href="#更新视图定义" class="headerlink" title="更新视图定义"></a>更新视图定义</h3><p>当视图有以下情况时不可更新</p><ul><li>聚合函数</li><li>distinct 关键字</li><li>group by子句。</li><li>order by子句。</li><li>having子句</li><li>union子句。</li><li>位于选择列表的子查询.</li><li>from子句中包含多个表</li><li>select语句中引用了不可更新视图。</li><li>where子句中的子查询，引用from子句中的表。</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>概念<br>触发器是指被指定关联到一个表的数据库对象，当一个表的特定事件出现时，它将会被激活并执行相应的操作。<br>触发器保障数据库中数据的完整性，以及多个表之间的一致性。<br>触发器就是MySQL响应insert、update、delete语句而自动执行的一条MySQL语句(或位于begin和end语句之间的一组MySQL语句)。</p><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create </span><br><span class="line">trigger trigger_name trigger_time trigger_event</span><br><span class="line">on tb_name for each row trigger_body;</span><br></pre></td></tr></table></figure><p>trigger_name:触发器名称<br>trigger_time:触发器被触发的时刻，有两个选项before和after。如果用于验证新数据是否满足限制使用before<br>trigger_event:触发事件，用于指定激活触发器的种类，其可以是下述值之一:<br>    (1).insert,load data<br>    (2).update<br>    (3).delete<br>tb_name:与触发器相关的表名，必须引用永久性表。同一个表不能有两个相同触发时刻和触发事件的触发器。如两个after update触发器。<br>for each row:指定对于受触发事件影响的每一行都要激活触发器的动作。如插入多行数据，每一行都会执行触发器动作。<br>trigger_body:触发器动作主体，可以使用begin…end语句。每个表最多只能有6个触发器。</p><p>查看已有的触发器</p><p><code>show triggers [{from | in} db_name];</code></p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><code>drop trigger [if exists] [schema_name.] trigger_name;</code><br>schema_name:数据库名</p><h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><p> (1).insert触发器<br>    insert触发器可引用一个new表访问被插入的行，new表中的值可以被更新。<br>    对于auto_increment列，在触发器执行后将包含新的自动生成值。<br> (2).delete触发器<br>    delete触发器可以引用一个old表访问被删除的行，该表不可更新。<br> (3).update触发器<br>    update触发器可以引用new表和old表。<br>    当触发器涉及对表自身的更新操作时，只能使用before update触发器</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>在指定时刻执行某些特定任务就是事件。<br>        使用事件必须打开event_scheduler<br>打开event_scheduler的方法<br> (1).set global event_scheduler=1;<br> (2).set @@event_scheduler=1;<br>查看event_scheduler是否打开<br> <code>select @@event_scheduler;</code><br> <code>show variable like &#39;event_scheduler&#39;;</code></p><h3 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h3><p>create<br>event<br>[if not exists]<br>event_name<br>on schedule schedule<br>[enable | disable | disable on slave]<br>do event body<br>schedule的格式<br>at timestamp[+interval interval]…]<br>| every interval<br>[starts timestamp [+ interval interval]…]<br>[ends timestamp [+ interval interval]…]</p><p>interval的格式<br>quantity {year | quarter | month | day<br>| hour | minute| week | second<br>| year_month | day_hour | day_minute | day_second<br>| hour_minute | hour_second | minute_second}</p><p>event_name:事件名字<br>at子句:指定事件在某一刻发生。timestamp表示一个具体的时间点。quantity是间隔时间的数值<br>every子句:指定事件多久发生一次。starts表示开始时间，ends表示结束时间。<br>event_body：事件的动作体，可以使用begin…end语句<br>enable | disable | disable on slave:表示事件的状态,enable表示活动，disable表示关闭的，disable on slave表示在从机中是关闭的。</p><h3 id="修改事件"><a href="#修改事件" class="headerlink" title="修改事件"></a>修改事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter </span><br><span class="line">event event_name</span><br><span class="line">[ on schedule schedule]</span><br><span class="line">[rename to new new_event_name\</span><br><span class="line">[enable | disable | disable on slave]</span><br><span class="line">[do event_body]</span><br></pre></td></tr></table></figure><h3 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h3><p><code>drop event [if exists] event_name;</code></p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是一组为了完成某特定功能的SQL语句集，其实实质上就是一段存放在数据库中的代码。</p><p>它可以由声明式的SQL语句(如CREATE、UPDATE、SELECT等语句)和过程式SQL语句(如IF-THEN-ELSE控制结构语句)组成。</p><p>存储过程的优点:</p><ul><li>可增强SQL语言的功能和灵活性。存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li><li>良好的封装性。</li><li>高性能</li><li>可减少网络流量</li><li>存储过程可作为一种安全机制来确保数据库的安全性和数据的完整性。</li></ul><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">PROCEDURE SP_NAME([PROC_PARAMETER[...]])</span><br><span class="line">[CHARACTERISTIC...]ROUTINE_BODY</span><br></pre></td></tr></table></figure><p>PROC_PARAMETER的格式:</p><p>[in| out | inout] param_name type</p><p>type的格式:</p><p>mysql所有有效的数据类型。</p><p>characteristic的格式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMENT &apos;string&apos;</span><br><span class="line">| LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMIISTIC</span><br><span class="line">| &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125;</span><br><span class="line">| SQL_SECURITY &#123;DEFINER | INVOKER&#125;</span><br></pre></td></tr></table></figure><p>runtine_body的格式:</p><p>有效的SQL语句(集)</p><p>说明</p><ul><li><p>sp_name:存储过程名，如果创建的存储过程作用于别的数据库，则在存储过程名前加上数据库限定。</p></li><li><p>proc_parameter:存储过程的参数列表。in:输入参数 out:输出参数 inout:输入/输出参数。避免参数名和表的字段名相同。</p></li><li><p>characteristic</p><p>​    ① COMENT ‘string’:用于对存储过程的描述。该描述可以通过SHOW CREATE PROCEDURE来显示。</p><p>​    ② LANGUAGE SQL:指明编写这个存储过程的语言为SQL语言。</p><p>​    ③ DETERMINISTIC:如果设置为DETERMINISTIC，表示存储过程的对同样的参数返回同样的结果。如果设置 </p><p>​         为NOT DETERMINISTIC，表示同样的参数不一定返回同样的结果。</p><p>​    ④ CONTAINS SQL | NO SQL | READS SQL | MODIFIES SQL DATA:CONTAINS SQL表示存储过程包含读或 </p><p>​         或写的SQL语句，NO SQL表示存储过程不包含SQL语句，READS SQL DATA表示存储过程包含只读的SQ</p><p>​         L语句，MODIFIES SQL DATA表示存储过程包含写数据的SQL语句。</p></li><li><p>routine_body:存储过程的主体部分。即存储过程体。</p></li></ul><p><strong>DELIMITER</strong></p><p>更换语句结束符</p><p>例:</p><p>delimiter $$</p><p>此时结束符变为$$</p><h3 id="储存过程体"><a href="#储存过程体" class="headerlink" title="储存过程体"></a>储存过程体</h3><ol><li><p>局部变量</p><p><code>decare var_name[,...]type[default value]</code></p><p>var_name:变量名</p><p>type:变量数据类型</p><p>default:为变量指定默认值。没有指定默认为NULL。</p><p>说明:</p><ul><li>局部变量只能在存储过程的BEGIN…END语句中声明。</li><li>局部变量必须在存储过程体的开头处声明。</li><li>局部变量的作用范围仅限于声明它的BEGIN…END语句块，其他语句块中的不可以使用它</li><li>局部变量不同于用户变量，区别:用户变量定义时用@标识，用户变量的作用范围是整个会话中。</li></ul></li><li><p>SET语句</p><p>可以通过set语句为变量赋值。</p><p><code>set var_name=expr[,var_name=expr]...</code></p></li><li><p>SELECT…INTO语句</p><p>select…into语句可以将结果集中的数据赋值变量。</p><p><code>select col_name[...]into var _name[...] table_expr</code></p><p><strong>注意:</strong></p><p>select…into语句返回的结果只能是一行。</p></li><li><p>流程控制语句</p><ol><li><p>条件控制语句</p><p>常用的条件判断语句有IF-THEN-ELSE语句和CASE语句。</p><p>IF-THEN-ELSE:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF search_condition THEN statement_list</span><br><span class="line">[ELSEIF search_condition THEN statement_list]...</span><br><span class="line">[ELSE statement_list]</span><br><span class="line">ELSE IF</span><br></pre></td></tr></table></figure><p>如果使用的是<code>ELSEIF</code>可以使用end if就结束该语句。</p><p>如果使用的是<code>ELSE IF</code>则需要每一个if使用一个end if。</p><p>CASE:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">WHEN when_value THEN statement_list</span><br><span class="line">[WHEN when_value THEN statement_list]</span><br><span class="line">[ELSE statement_list]</span><br><span class="line">END CASE</span><br></pre></td></tr></table></figure><p>或:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE </span><br><span class="line">[WHEN search_condition THEN statement_list]</span><br><span class="line">[ELSE statement_list]</span><br><span class="line">END CASE</span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><p>常用的循环语句有WHILE语句，REPEAT语句和LOOP语句。</p><p>WHILE:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:]WHILE search_condition DO</span><br><span class="line">statement_list</span><br><span class="line">END WHILE[end_label]</span><br></pre></td></tr></table></figure><ul><li><p>while循环先判断search_condition是否为真，倘若为真，则执行statement_list中的语句，然后再次执行判断，如果仍然为真则继续循环，直至条件判断不为真时结束循环。</p></li><li><p>begin_label和end_label是WHILE语句的标注，且必须使用相同的名字，并成对出现。</p></li></ul><p>REPEAT:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:]REPEAT</span><br><span class="line">statement_list</span><br><span class="line">UNTIL serach_condition</span><br><span class="line">END REPEAT[end_label]</span><br></pre></td></tr></table></figure><ul><li>REPEAT语句先执行statement_list中的语句，然后判断search_condition是否为真，倘若为真则结束循环，如若不为真则继续循环。</li><li>WHILE 和 REPEAT的区别是WHILE先判断，条件为真就继续，REPEAT是先执行后判断，条件不为真就继续。</li></ul><p>LOOP:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[begin_label:]LOOP</span><br><span class="line">statement_list</span><br><span class="line">END LOOP[end_label]</span><br></pre></td></tr></table></figure><ul><li>在循环体statement_list中语句会一直重复执行，直至循环使用LEAVE语句退出。</li><li>LEAVE语句的格式:<code>LEAVE label</code>,这里的label是LOOP语句中自定义的名字，LEAVE是退出结束一个循环。</li><li>ITERATE语句，可以使用在LOOP,REPEAT,WHILE子句中，用于表示退出循环。只能结束一次循环，并不能退出当前循环。</li></ul></li></ol></li><li><p>游标</p><p>游标是一个被SELECT检索出来的结果集。</p><p><strong>注意</strong></p><ul><li>MySQL对游标的支持是从MySQL5.0开始的，之前的MySQL版本无法使用游标。</li><li>游标只能用于存储过程或存储函数中，不能单独在查询操作中使用。</li><li>在存储过程或存储函数中可以定义多个游标，但是在一个BEGIN…END语句块中每个游标的名字必须是唯一的。</li><li>游标不是一条SELECT语句，是被SELECT语句检索出来的结果集。</li></ul><h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><ul><li><p>声明游标</p><p><code>DECLARE cursor_name CURSOR FOR select_statement</code></p><p>cursor_name:游标名称</p><p>select_statement:指定一个SELECT语句，其返回一行或多行的数据。这里的SELECT语句不能有INTO子句。</p></li><li><p>打开游标</p><p>游标在声明后必须打开才能使用</p><p><code>OPEN cursor_name</code></p></li><li><p>读取数据</p><p><code>FETCH cursor_name INTO var_name[,var_name]...</code></p><p>cursor_name:指定已打开的游标</p><p>var_name:用于指定存放数据的变量名。</p><p>FETCH…INTO语句与SELECT…INTO语句具有相同的意义，FETCH语句是将游标指向的一行数据赋给一个变量，这些变量的数目必须等于声明游标时SELECT子句中选择列的数据。游标相当于一个指针，指向当前行的数据。</p></li><li><p>关闭游标</p><p>在结束游标使用后，必须关闭游标</p><p><code>CLOSE cursor_name</code></p><p>如果没有明确关闭游标，MySQL将会到达END语句时自动关闭它。</p></li></ul><p><strong>句柄</strong></p><p>句柄可以移动游标。</p><p>`DECLARE CONTINUE HANDLER FOR NOT FOUND</p><p>如果没有数据就将found设置为false;</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL数据库总结&quot;&gt;&lt;a href=&quot;#MySQL数据库总结&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库总结&quot;&gt;&lt;/a&gt;MySQL数据库总结&lt;/h1&gt;&lt;h3 id=&quot;数据库的常见问题&quot;&gt;&lt;a href=&quot;#数据库的常见问题&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jQuery笔记</title>
    <link href="http://yoursite.com/2019/12/11/jQuery%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/11/jQuery%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-11T07:54:02.901Z</published>
    <updated>2019-12-11T07:54:02.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery笔记"><a href="#jQuery笔记" class="headerlink" title="jQuery笔记"></a>jQuery笔记</h1><p>jQuery 很容易学习。</p><p>jQuery 是一个 JavaScript 库。</p><p>jQuery 极大地简化了 JavaScript 编程。</p><p>jQuery是一个轻量级的”写的少，做的多”的JavaScript库。  </p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法:"></a>基础语法:</h3><p><code>$(selector).action()</code>,<code>$</code>表示JQuery,<code>selector</code>表示选择器,<code>action</code>表示执行的动作。  </p><p><strong>文档就绪事件</strong><br>该事件可以防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。<br><img src="../../../../images/jQueryImg/ready.png" alt="ready"><br>简写语法:  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function ()&#123;</span><br><span class="line">// 这里开始写jQuery代码...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上的方法都实现文档就绪后执行jQuery方法。<br><strong>JavaScript的window.load方法和jQuery中的ready方法的区别:</strong><br><img src="../../../../images/jQueryImg/load%E6%96%B9%E6%B3%95%E5%92%8Cready%E6%96%B9%E6%B3%95%E5%88%86%E7%9A%84%E5%8C%BA%E5%88%AB.jpeg" alt="load和ready的区别"></p><p>jQuery入口函数与JavaScript入口函数的区别:  </p><ul><li>jQuery的入口函数是在html所有标签(DOM)都加载之后，就执行jQuery代码。</li><li>JavaScript的window.onload事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。  </li></ul><h3 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><ol><li>元素选择器:<code>$(&quot;div&quot;)</code>选择所有的div元素。</li><li>id选择器:<code>$(&quot;#one&quot;)</code>选择id=one的元素。</li><li>类选择器:<code>$(&quot;.two&quot;)</code>选择class=two的所有元素。</li><li>并集选择器:<code>$(&quot;selector,selector1,...,selectorn&quot;)</code>选择所有selector元素，所有selector1元素，…，所有selectorn元素。</li><li>全局选择器:<code>$(&quot;*&quot;)</code>选择所有元素。</li></ol><h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><ol><li>后代选择器:<code>$(&quot;div span&quot;)</code>获取div后代中所有span元素。</li><li>子类选择器:<code>$(&quot;div&gt;span&quot;)</code>获取div直接子类中所有span元素。</li><li>相邻元素选择器:<code>$(&quot;div span&quot;)</code>获取div的下一个元素，span元素。</li><li>同辈选择器:<code>$(&quot;div~span&quot;)</code>获取div之后的所有span元素。</li></ol><p>####　属性选择器:</p><ol><li><p>[attribute]:<code>$(&quot;[href]&quot;)</code>获取包含href属性的所有元素 。</p></li><li><p>[attribute=value]:<code>$(&quot;href=&#39;http&#39;&quot;)</code>获取所有href=”http”的元素。</p></li><li><p>[attribute!=value]:<code>$(&quot;href!=&#39;http&#39;&quot;)</code>获取所有href!=”http”的元素。</p></li><li><p>[attribute^=value]:<code>$(&quot;href^=&#39;bc&#39;&quot;)</code>获取所有href=”abc”,href属性=bc结尾的元素。</p></li><li><p>[selector] [selector1] […] [selectorn]:<code>$(&quot;li[id][href=&#39;http&#39;][width=&#39;100px&#39;]&quot;)</code>获取含有id属性并且href=”http”,width=”100px”的所有li元素。</p></li></ol><h4 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器:"></a>基本过滤选择器:</h4><ol><li><code>:first</code>     选择第一个元素      <code>$(&quot;div:first&quot;)</code> 选择第一个div元素</li><li><code>:last</code>       选择最后一个元素  <code>$(&quot;div:last&quot;)</code>选择最后一个div元素</li><li><code>:even</code>       选择所有下标为偶数的元素(下标从0开始)    <code>$(&quot;div:even&quot;)</code>选择下标为偶数的所有div元素</li><li><code>:odd</code>         选择所有下标为奇数的元素(下标从0开始)    <code>$(&quot;div:odd&quot;)</code>选择下标为奇数的所有div元素</li><li><code>:eq(index)</code>      选择所有id=index的元素   <code>$(&quot;div:eq(1)&quot;)</code>选择下标为1的div元素</li><li><code>:gt(index)</code>      选择所有id&gt;index的元素   <code>$(&quot;div:gt(1)&quot;)</code>选择下标大于1的所有div元素。</li><li><code>:lt(index)</code>      选择所有id&lt;index的元素   <code>$(&quot;div:lt(2)&quot;)</code>选择下标小于2的所有div元素。</li><li><code>:not(selectors)</code>   选择不包括selectors的所有元素，selectors可以是多个，用<code>,</code>隔开。 <code>$(&quot;li:not(:first)&quot;)</code>选择除开第一个的所有li元素。</li></ol><h4 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器:"></a>内容过滤选择器:</h4><ol><li><p><code>:contains(text)</code>   选择元素内容包括text的所有元素。   <code>$(&quot;div:contains(&#39;hello&#39;)&quot;)</code>选择包含hello的所有元素。</p></li><li><p><code>:empty</code>            选择内容为空的所有元素。 <code>$(&quot;div:empty&quot;)</code>选择为空的div元素。</p></li><li><p><code>:has(selctor)</code>       选择含有选择器匹配的所有元素的元素。 <code>$(&quot;div:has(span)&quot;)</code>选择div含有span的所有span元素。</p></li><li><p><code>parent</code>                       匹配含有内容或文本的元素。  <code>$(&quot;div:parent&quot;)</code>选择含有内容的div元素。</p></li></ol><ul><li><p>可见性过滤选择器</p><ol><li><code>:hidden</code>      选择所有隐藏元素      <code>$(&quot;div:hidden&quot;)</code>选择所有隐藏的div元素。</li><li><code>visible</code>      选择所有显示元素    <code>$(&quot;div:visible&quot;)</code>选择所有可见的div元素。</li></ol></li></ul><h3 id="jQuery对样式操作"><a href="#jQuery对样式操作" class="headerlink" title="jQuery对样式操作"></a>jQuery对样式操作</h3><h5 id="css"><a href="#css" class="headerlink" title="css():"></a>css():</h5><p>设置指定元素的样式。  </p><p><code>$(&quot;div:first&quot;).css(&quot;color&quot;,&quot;red&quot;);</code> 设置第一个div的字体颜色为红</p><h5 id="addClass-class"><a href="#addClass-class" class="headerlink" title="addClass(class):"></a>addClass(class):</h5><p>为指定元素添加样式，class可以是多个。</p><h5 id="removeClass-“style”"><a href="#removeClass-“style”" class="headerlink" title="removeClass(“style”):"></a>removeClass(“style”):</h5><p>移除指定元素的样式,style可以是多个。</p><h5 id="toggleClass-class"><a href="#toggleClass-class" class="headerlink" title="toggleClass(class):"></a>toggleClass(class):</h5><p>实现样式切换。</p><h3 id="jQuery对元素操作"><a href="#jQuery对元素操作" class="headerlink" title="jQuery对元素操作"></a>jQuery对元素操作</h3><h5 id="html"><a href="#html" class="headerlink" title="html():"></a>html():</h5><p><code>html()</code>可以对元素内容进行操作，相当于js的innerHTML。</p><h5 id="text"><a href="#text" class="headerlink" title="text():"></a>text():</h5><p><code>text()</code>可以获取或设置元素的内容。</p><h5 id="val"><a href="#val" class="headerlink" title="val():"></a>val():</h5><p><code>val()</code>可以设置或获取元素的value值。</p><h5 id="attr"><a href="#attr" class="headerlink" title="attr():"></a>attr():</h5><p><code>attr()</code>用来设置或获取元素属性。</p><h5 id="removeAttr"><a href="#removeAttr" class="headerlink" title="removeAttr():"></a>removeAttr():</h5><p><code>removeAttr(&quot;title&quot;)</code>用来删除元素的属性。</p><h3 id="jQuery对节点操作"><a href="#jQuery对节点操作" class="headerlink" title="jQuery对节点操作"></a>jQuery对节点操作</h3><p><strong>$(selector): 通过选择器获取节点。</strong></p><p><strong>$(element):把DOM节点转换成jQuery节点。</strong></p><p><strong>$(html):使用HTML字符串创建节点。</strong></p><h4 id="元素内部插入节点"><a href="#元素内部插入节点" class="headerlink" title="元素内部插入节点"></a>元素内部插入节点</h4><p><code>append(content)</code>:   <code>$(A).append(B)</code>表示将B追加到A中。如: <code>$(&quot;ul&quot;).append($newNode);</code></p><p><code>appendTo(content)</code>:  <code>$(A).appendTo(B)</code>表示把A追加到B中。 如: <code>$newNode.appendTo(&quot;ul&quot;);</code></p><p><code>prepend(content)</code>: <code>$(A).prepend(B)</code>表示将B前置插入到A中。如<code>$(&quot;ul&quot;).prepend($newNode);</code></p><p><code>prependTo(content)</code>: <code>$(A).prependTo(B)</code>表示将A前置插入到B中。如: <code>$newNode.prependTo(&quot;ul&quot;);</code></p><h4 id="插入同级元素"><a href="#插入同级元素" class="headerlink" title="插入同级元素"></a>插入同级元素</h4><p><code>after(content)</code>: <code>$(A).after(B)</code>表示将B插入到A之后。 <code>$(&quot;ul&quot;).after($newNode)</code>。</p><p><code>insertAfter(content)</code>: <code>$(A).insertAfter(B)</code>表示将A插入到B之后。如<code>$newNode.insertAfter(&quot;ul&quot;);</code></p><p><code>before(content)</code>: <code>$(A).before(B)</code>表示将B插入到A之前。如<code>$(&quot;ul&quot;).before($newNode);</code></p><p><code>insertBefore(content)</code>: <code>$(A).insertBefore(B)</code>表示将A插入到B之前。如<code>$newNode.insertBefore(&quot;ul&quot;);</code></p><h4 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h4><p><code>clone()</code></p><p>例:</p><p>​    <code>$(&quot;ul li:eq(1)&quot;).clone(true).appendTo(&quot;ul&quot;);</code></p><p>将ul下的第一个li复制给ul。</p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><code>remove()</code>:删除整个节点。</p><p><code>empty()</code>:清空节点内容。</p><h4 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h4><p><code>children()</code>：获取元素的所有子元素，只能获取下一级子元素。 如 <code>div&gt;span&gt;a</code>只能获取 所有span元素。</p><p><code>find()</code>:获取元素的所有指定后代元素。 如<code>div&gt;span&gt;a&gt;span</code>获取div下的所有span元素(包扩a元素下的span)。</p><h4 id="获取同级元素"><a href="#获取同级元素" class="headerlink" title="获取同级元素"></a>获取同级元素</h4><p><code>next([expr])</code>: 用于获取紧邻匹配元素之后的元素。</p><p><code>nextAll([expr])</code>:用户获取紧邻匹配元素之后的所有同级元素。</p><p><code>prev([expr])</code>:用于获取紧邻匹配元素之前的元素。</p><p><code>prevAll([expr])</code>:用户获取紧邻匹配元素之前的所有同级元素。</p><p><code>siblings([expr])</code>:用于获取位于匹配元素前面和后面的所有同辈元素。</p><h4 id="遍历前辈元素"><a href="#遍历前辈元素" class="headerlink" title="遍历前辈元素"></a>遍历前辈元素</h4><p><code>parent()</code>:获取元素的父级元素。</p><p><code>parents()</code>:获取元素的祖先元素。</p><h3 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p><code>click()</code>：触发或将函数绑定到指定元素的click事件。</p><p><code>mouseover()</code>: 触发或将函数绑定到指定的mouseover事件。</p><p><code>mouseout()</code>:触发或将函数绑定到指定的mouseout事件。</p><p>……</p><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p><code>keydown()</code>: 触发或将函数绑定到指定元素的keydown事件。</p><p><code>keyup()</code>: 触发或将函数绑定到指定元素的keyup事件。</p><p><code>keypress()</code>: 触发或将函数绑定到指定元素的keypress事件。</p><h4 id="其它事件"><a href="#其它事件" class="headerlink" title="其它事件"></a>其它事件</h4><p><code>focus()</code>: 触发或将函数绑定到指定元素的focus事件。</p><p><code>blur()</code>: 触发或将函数绑定到指定的blur事件。</p><p><code>submit()</code>: 当该提交表单时，会发生submit事件，该事件只适用于表单元素。</p><h4 id="绑定或取消事件"><a href="#绑定或取消事件" class="headerlink" title="绑定或取消事件"></a>绑定或取消事件</h4><p><code>on()</code>: 在选择元素上绑定一个或多个事件的事件处理函数。</p><p><code>off()</code>: 在选择元素上解绑一个或多个事件的事件处理函数。</p><p><strong><code>off()</code>不带参数，取消所有事件</strong></p><h3 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h3><p><code>show()</code>: 在显示元素时，能定义显示元素时的效果。比如显示速度。 可取值: <strong>毫秒,slow,normal,fast</strong></p><p><code>hide()</code>: 用于隐藏元素。</p><p><code>toggle()</code>: 用于切换元素的可见状态。</p><p><code>fadeIn()和fadeOut()</code>: 可以通过改变元素的透明度实现淡入淡出效果。</p><p><code>fadeToggle()</code>: 可以切换元素的淡入淡出效果。</p><p><code>slideDown()</code>: 可以使元素逐步缩短直至隐藏。</p><p><code>slideUp()</code>: 则使元素逐步缩短直至隐藏。</p><p><code>slideToggle()</code>: 可以使元素在上拉和下拉切换。</p><p><code>anmite()</code>:  可以通过控制元素改变样式的过程的时间来实现动画效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery笔记&quot;&gt;&lt;a href=&quot;#jQuery笔记&quot; class=&quot;headerlink&quot; title=&quot;jQuery笔记&quot;&gt;&lt;/a&gt;jQuery笔记&lt;/h1&gt;&lt;p&gt;jQuery 很容易学习。&lt;/p&gt;
&lt;p&gt;jQuery 是一个 JavaScript 库。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="http://yoursite.com/2019/12/10/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/10/python%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-09T16:19:39.003Z</published>
    <updated>2019-12-09T16:19:39.003Z</updated>
    
    <content type="html"><![CDATA[<p>Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。  </p><h3 id="python代码编写"><a href="#python代码编写" class="headerlink" title="python代码编写"></a>python代码编写</h3><h6 id="python的注释"><a href="#python的注释" class="headerlink" title="python的注释"></a>python的注释</h6><p>1.单行注释<br><code>单行注释:</code><img src="../../../../images/py_img/danhang.png" alt="单行注释"><br>2.多行注释<br><code>多行注释1:</code><img src="../../../../images/py_img/duohang_1.png" alt="多行注释1"><br><code>多行注释2:</code><img src="../../../../images/py_img/duohang_2.png" alt="多行注释2">  </p><p>3.空格缩进<br>python中空格表示缩进<br>例如:<br><img src="../../../../images/py_img/for_suojin.png" alt="for循环"><br>如果上面的for循环中，没有缩进<code>print()</code>将不是for循环的语句<br><strong>在python的代码的编写中，保持良好的代码缩进风格，也要使用好空格</strong><br>例如:<br><img src="../../../../images/py_img/kg_use.png" alt="空格使用"><br>在使用操作符的时候最好在操作符两端加上一个空格，在使用<code>,</code>号时最好在<code>,</code>号后加一个空格  </p><h3 id="python变量和数据类型"><a href="#python变量和数据类型" class="headerlink" title="python变量和数据类型"></a>python变量和数据类型</h3><h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6><ul><li>python中的变量必须先声明后使用，不然会报未定义错误  </li><li><strong>python中没有常量，python中的常量知识逻辑上的常量</strong>  </li><li>变量可以用<code>del</code>删除，删除后再使用会报未定义错误，对象没有引用会被垃圾回收器回收。  </li><li>python中定义变量不用声明数据类型，变量的数据类型由变量值决定。<br>例如:<br><img src="../../../../images/py_img/bldy.png" alt="定义变量"><br>b是<code>int</code>类型,c是<code>float</code>类型,d是<code>bool</code>类型,e是<code>str</code>类型,f也是<code>str</code>类型  </li></ul><h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p>python是动态类型语言(变量类型由变量值确定)，也是强类型语言(每个对象都有数据类型，只支持该数据类型的操作)  </p><p><strong>类型转换:</strong><br>小数转整数:截掉小数保留整数<code>int(3.23)=&gt;3</code><br>字符串数字:转成对应的整数<code>int(&quot;1234&quot;)=&gt;1234</code><br>布尔值转整数:True转换1，false转成0<code>int(True)=&gt;1,int(False)=&gt;0</code><br>整数和小数相加自动转换成小数<br><code>float(x)</code>将x转换成<code>float</code>类型，x不变，产生新的对象。</p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><code>+</code>:加号运算符<br><code>-</code>:减号运算符<br><code>*</code>:乘号运算符<br><code>/</code>:除号运算符(有小数)<br><code>//</code>:加号运算符(小数截掉)<br><code>%</code>:取余运算符<br><code>**</code>:乘方运算符<br><code>==</code>:恒等运算符，判断对象内容是否相同<br><code>is</code>:判断两个对象是否相同(比较地址)，<strong>在python中解释器会缓存(-5-255)的整数数，这之间的数都是同一对象(两个对象值相等就相等)。在pycharm中所有整数和小数都是同一对象。</strong><br><code>is not</code>:判断两个对象是否是不同对象。<br><code>is</code>主要用于判断变量和None  </p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>字符串的本质是字符序列，python中的字符串是不可变的</strong>。<br>python不支持字符，单个字符也是字符串。<br>python3支持unicode编码,默认就是16位的unicode编码  </p><h5 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h5><p><code>a=&#39;abc&#39;或a=&quot;abc&quot;</code>,如果字符串中存在单引号可以用双引号包裹字符串，反之字符串中有双引号则用单引号包裹字符串。也可以在字符串中用<code>\&#39;</code>转义单引号，同样双引号也可以儿这样转义。  </p><h5 id="字符串处理常用方法"><a href="#字符串处理常用方法" class="headerlink" title="字符串处理常用方法"></a>字符串处理常用方法</h5><p><code>ord()</code>:将字符转成Unicode码的十进制表示。<br><code>chr()</code>:将十进制数字转换成Unicode码的对应字符。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。  &lt;/p&gt;
&lt;h3 id=&quot;python代码编写&quot;&gt;&lt;a href=&quot;#py
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
